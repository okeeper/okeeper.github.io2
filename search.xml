<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/cao-zuo-xi-tong-yuan-li-nei-cun-guan-li/"/>
      <url>/cao-zuo-xi-tong-yuan-li-nei-cun-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理的目标"><a href="#内存管理的目标" class="headerlink" title="内存管理的目标"></a>内存管理的目标</h1><p>1) 实现内存分配、内存回收等操作<br>2) 提高内存的利用率和内存的访问速度<br>即充分利用现有的内存资源，为应用程序提供方便的内存使用方式和一个快速、安全且充分大的存储器</p><h1 id="程序的链接和装入"><a href="#程序的链接和装入" class="headerlink" title="程序的链接和装入"></a>程序的链接和装入</h1><p>链接要解决的问题是将编译后的目标模块装配成一个可执行的程序，分为静态链接和动态链接</p><h3 id="1-程序链接"><a href="#1-程序链接" class="headerlink" title="1. 程序链接"></a>1. 程序链接</h3><p><strong>静态链接</strong>：在程序运行之前，用链接程序将目标模块连接成一个完整的转入模块，任务：一是对逻辑地址进行修改，二是转换外部调用符号<br>优点：运行速度快 缺点：可执行文件较大，占用空间大，系统开销大，程序开发不够灵活，修改一个模块会导致整个程序重新连接</p><p><strong>动态链接</strong><br>可将某些目标模块的链接推迟到这些模块中的函数要被调用时再进行。<br>优点：节省内存和外存空间，方便程序开发<br>缺点：增加了运行时的开销，是程序运行时速度变慢</p><h3 id="2-程序的装入"><a href="#2-程序的装入" class="headerlink" title="2.程序的装入"></a>2.程序的装入</h3><p>装入方式：绝对装入方式、可重定位装入（静态装入方式）和动态运行时装入方式</p><p><strong>绝对装入方式</strong>：编译程序已知程序在内存中的位置，编译时产生物理地址的目标代码，转入程序按照装入模块的物理地址将程序和数据装入内存<br><strong>可重定位装入方式</strong>：编译时不知道程序在内存中的位置，那么编译时就必须生成可重定位的代码，其中的地址都是逻辑地址，在程序转入内存时，再把逻辑地址映射为物理地址。程序装入时对目标称重的指令和数据地址修改的过程称之为重定位转入</p><p>静态装入方式的特点：1)编译程序使目标模块的地址从0开始<br>2) 程序装入时，装入程序根据内存的使用情况将装入模块的装入内存的某个位置，并对模块进行重定位。物理地址=有效的逻辑地址+程序在内存中的其实位置</p><p>动态运行时装入：当一个进程在被换出之前的内存地址与后来被从外存调入时的位置不同，这是地址映射延迟到进程执行时再进行。</p><h2 id="3-连续分配的存储管理方式"><a href="#3-连续分配的存储管理方式" class="headerlink" title="3.连续分配的存储管理方式"></a>3.连续分配的存储管理方式</h2><ol><li>单一连续去分配方式<br>适合于单用户单任务系统，内存分为系统区和用户区</li><li>固定分区分配<br>将用户内存空间分配成若干固定大小的区域，每个区域运行一道用户程序；分区的数量固定的，大小也是固定的<br>每个分区大小相等的分配方式缺点是：内存利用率低，主要用于一个计算机去控制多个相同对象的场合，如冶炼炉<br>在一些实时系统中，固定分区的分配方式还是简单而有效的</li><li>动态分区分配方式<br>用户分区的数量和大小都是动态变化的<br>分配原理：系统初始只有一个大的空闲分区，当进程请求内存资源时，系统根据请求资源的大小分配一片空闲区域给进程，当运行一段时间后，空闲分区可能散布在不连续的区域，这时候系统会维护一个记录当前空闲分区的数据接口，当进程请求内存时，系统从所有空闲分区中找到一个合适大小的空间给进程。<br>数据结构：空闲分区表和空闲分区链<br>空闲分区链可以动态为每个分区建立一个节点，每个节点包括分区大小、分区起始地址、指向前一个空闲分区节点的指针、指向后一个空闲分区节点的指针。每一个节点占用的内存动态分配、动态回收。</li></ol><p><strong>动态分区分配算法</strong><br>1) 首次适应算法FF<br>要求空闲分区链以地址递增的顺序进行连接，每次从链首开始查找，低地址空间可能会被反复划分 缺点：造成空间浪费，内存碎片<br>2) 循环首次适应算法NF<br>不在每次从链首开始查找，而是从上一次查找的空闲分区的下一个分区开始查找，每次应设置一个起始查找指针，指示下一次查找的分区<br>3) 最佳适应算法BF<br>为了方便查找，把所有空闲区，按照空闲大小递增的顺序进行排列，总是把大小和进程请求的内存空间大小接近的空间分配给进程。<br>优点：避免了大材小用，提高了内存的利用率<br>缺点：容易留下难以使用的小空闲区</p><h2 id="4-基于分页存储的管理方式"><a href="#4-基于分页存储的管理方式" class="headerlink" title="4. 基于分页存储的管理方式"></a>4. 基于分页存储的管理方式</h2><p>把进程的存储在内存中的物理地址不连续的区域，这种内存管理方式称为离散内存管理方式。<br>离散内存管理分配内存空间的管理方式有：<strong>分页存储管理，分段存储管理、段也式存储管理</strong></p><p><strong>页</strong>：将一个进程的逻辑地址空间分为若干个大小相等的片，，称之为页<br><strong>页框</strong>：将物理内存地址分成与页大小相同的若干个存储块，称之为页框</p><p><strong>业内碎片</strong>：进程的最后一页一般装不满一个叶框，而形成了不可利用的碎片称为页内碎片。</p><p><strong>页表</strong>：实现页号到页框的映射，在基本的分页制度中，每个进程有一个页表，进程的每一页在页表中有一个对应的页表项，页表在内存中连续存放。</p><p><strong>分页管理方式的地址结构</strong><br>页的存储结构：<br>页号P   页内偏移量W<br>若用m位标识逻辑地址，页大小为2的n次方，则用低n位表示页内偏移量w,用高位m-n位表示P</p><p>分页地址变换：实现逻辑地址到物理地址的转换<br>公式:物理地址=页框号x页框大小 + 页内偏移量</p><p>为了减少cpu在有效访问内存时间上的开销，提高内存的速度，引入了快表机制<br><strong>快表</strong>:也称转换后的缓冲是为了提高访问内存速度而采用的专用缓存，存放最近访问过的页表项。</p><h2 id="4-基于两级页表和多级页表的管理方式"><a href="#4-基于两级页表和多级页表的管理方式" class="headerlink" title="4. 基于两级页表和多级页表的管理方式"></a>4. 基于两级页表和多级页表的管理方式</h2><p>页表再分页，就形成了两级或者多级页表<br>两级页表：将页表再分页，使得每个页表分页的大小与内存页框的大小相同<br>页目录号实际是一个索引值，根据p1从也木勒表项中找到页表所在的页框号，页号p2是页表中的偏移量，根据p2可以知道应该从也飙中的第p2项找到进程页所在的页框号。</p><h2 id="5-基于分页虚拟存储的系统"><a href="#5-基于分页虚拟存储的系统" class="headerlink" title="5. 基于分页虚拟存储的系统"></a>5. 基于分页虚拟存储的系统</h2><p>虚拟存储技术实现的基本思想是：只把进程的一部分装入内存，在进程执行的过程中，cpu访问内存如果发现所访问的内容不再内存中，则通过异常处理将所需的内容从外存调入内存。<br>虚拟存储技术的好处：<br>1) 提高内存的利用率<br>2) 提高多道程序度<br>3) 把逻辑地址空间和物理地址空间分开，程序员不用关心物理内存的容量对编程的限制。</p><p><strong>虚拟存储技术的特征</strong><br>1) 离散性<br>2) 多次性<br>3) 对换性</p><h2 id="6-页的分配策略"><a href="#6-页的分配策略" class="headerlink" title="6. 页的分配策略"></a>6. 页的分配策略</h2><p>最少页框数：是指保证进程正常运行所需的最少页框数。操作系统为进程分配的页应该大于或者等于最少页框数</p><p>页分配策略：固定分配策略和可变分配策略<br>页置换策略：局部置换和全局置换。1)局部置换发生置换时，只从请求置换的进程本身的内存页中选择淘汰页，腾出内存空间 2)全局置换是指发生置换时，从所有进程的内存页中选择淘汰的页。<br>也有局部置换和全局置换组合的策略：1)固定分配局部置换 2可变分配局部置换 3)可变分配全局置换</p><p><strong>分配算法</strong><br>1) 平均分配算法n进程m页框，则分配INT[m/n]个页框，余数放入缓冲<br>2) 按比例分配算法，为进程分配的页框数=进程页数/所有进程页数总和 * 总页框数<br>3) 优先权的分配算法</p><h2 id="7-页调入策略"><a href="#7-页调入策略" class="headerlink" title="7.页调入策略"></a>7.页调入策略</h2><p>1) 系统可以在进程需要时将页调入内存，有利于内存的使用率，但是对系统的时间性能不利<br>2) 采用预先调入页的策略，将预计不久后会被访问的页预先调入内存</p><h2 id="8-页置换算法"><a href="#8-页置换算法" class="headerlink" title="8.页置换算法"></a>8.页置换算法</h2><p>1) 最佳置换算法ORA:该算法选择以后永远不会被访问的页或者长时间不会被访问的页作为换出页<br>2) 先进先出置换算法FIFO：最简单。当选择换出页时，选择进入内存时间最早的页（用指针指示当前调入新页时，应当淘汰的那个也在队列中的位置，换出后，指针指向下一个应该淘汰的页）<br>3) 最久未使用的LRU置换算法：性能较好的算法，该算法是选择最久未使用的页换出。<br>4) 其他置换算法：附件引用位算法、简单clock算法、改进型clock算法、最少使用置换算法、页缓冲算法</p><h2 id="9-分段存储管理"><a href="#9-分段存储管理" class="headerlink" title="9.分段存储管理"></a>9.分段存储管理</h2><p>引入分段机制的优点是方便编程、分段共享、分段保护、动态链接以及存储空间的动态增长</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/cao-zuo-xi-tong-yuan-li-jin-cheng-diao-du-yu-si-suo/"/>
      <url>/cao-zuo-xi-tong-yuan-li-jin-cheng-diao-du-yu-si-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="一、进程调度"><a href="#一、进程调度" class="headerlink" title="一、进程调度"></a>一、进程调度</h1><p>进程的调度室指按照某种策略或算法从就绪进程中为当前空闲的cpu选择在其上运行的新进程</p><h1 id="二、进程的调度算法"><a href="#二、进程的调度算法" class="headerlink" title="二、进程的调度算法"></a>二、进程的调度算法</h1><p>##1. 时间概念<br><strong>周转时间</strong>是指从作业开始提交给系统开始，到作业完成为止系统的<br><strong>平均周转时间T</strong>=N各种作业的周转时间之和除以n<br><strong>带权周转时间</strong>=作业的周转时间/系统为它提供服务时间<br><strong>响应时间</strong>=用户从提交一个请求开始至系统首次响应的时间为止的一段时间<br><strong>截止时间</strong>=是指某个人物必须开始执行的最迟时间，或者必须完成的最迟时间</p><h2 id="2-调度算法优劣的准则"><a href="#2-调度算法优劣的准则" class="headerlink" title="2. 调度算法优劣的准则"></a>2. 调度算法优劣的准则</h2><ul><li>周转时间短</li><li>响应时间快</li><li>截止时间保证</li><li>系统吞吐量高</li><li>CPU利用率好</li></ul><h2 id="3-调度算法"><a href="#3-调度算法" class="headerlink" title="3. 调度算法"></a>3. 调度算法</h2><ol><li><p>先来先服务(FCFS),从就绪队首选择最先到达就绪队列的进程<br>优缺点：FCFS适合长进程，不利于短进程，适合CPU繁忙型的进程，不适合IO繁忙型的进程</p></li><li><p>短进程调度优先(SPF)，短进程优先算法有效降低进程的平均等待时间，提高系统的吞吐量</p></li><li><p>调度算法优先(SPL),分为非抢占式优先调度算法，抢占式优先权调度；优先权的调度类型：静态优先权和动态优先权</p></li><li><p>时间片轮转调度算法(RR),时间片大小确认考虑的因素：</p><ol><li>系统对响应时间的要求，响应时间越短，时间片取值应该越小。</li><li>就绪队列中的进程数</li><li>系统的处理能力</li></ol></li><li><p>多级队列调度，不同的队列优先权不同，调度算法也可能不同</p></li><li><p>多级反馈队列调度，队列优先权越高，时间片越短，时间片通常成倍增长。</p></li></ol><p>##实时系统中的调度 </p><ol><li>提供必要的调度信息</li><li>系统处理能力强</li><li>采用抢占式调度机制</li><li>具有快速切换机制</li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是由于多个进程竞争共享资源引起的进程不能向前推进的僵死状态</p><p>产生死锁的原因：竞争死锁资源且分配资源的顺序不当<br>产生死锁的必要条件：</p><ol><li>互斥</li><li>请求保持</li><li>不剥夺</li><li>环路等待</li></ol><p>处理死锁的防范：</p><ol><li>预防死锁</li><li>避免死锁，资源分配的状态分为安全和不安全状态，不安全状态不一定产生死锁，但是系统进入安全状态一定不会产生死锁，这样就可以避免死锁的产生，银行家算法就是一种系统避免系统死锁的一种检测算法，其基本思想是：一个进程提出资源请求后，系统进行资源的试分配。然后检测此次分配是否处于安全状态，若安全则按分配方案分配资源，否则不进行分配资源。</li><li>检测并解除死锁</li><li>忽略死锁</li></ol><p>某系统中有3个并发进程，都需要同类资源4个，试问该系统保证不会发生死锁的最少资源数是<strong>__</strong><br>如果一个进程有m个资源它就能够结束，不会使自己陷入死锁中。因此最差情况是每个进程有m-1个资源并且需要另外一个资源。如果留下有一个资源可用，那么其中某个进程就能够结束并释放它的所有资源，使其它进程也能够结束。所以避免死锁的条件是：r≥p(m-1)+1。带入上述条件公式：<strong>r≥3*(4-1)+1=10</strong>。所以答案为10个。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/cao-zuo-xi-tong-yuan-li-jin-cheng-guan-li/"/>
      <url>/cao-zuo-xi-tong-yuan-li-jin-cheng-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="一、进程的概念"><a href="#一、进程的概念" class="headerlink" title="一、进程的概念"></a>一、进程的概念</h1><ol><li>进程是允许并发的程序在某个数据集合上运行的过程</li><li>进程是<strong>正文段</strong>、<strong>用户数据段</strong>和<strong>进程控制块</strong>共同组成的执行环境。</li></ol><h1 id="二、进程与程序的区别"><a href="#二、进程与程序的区别" class="headerlink" title="二、进程与程序的区别"></a>二、进程与程序的区别</h1><ol><li>程序是静态的，进程是动态的</li><li>程序是永久的，进程是暂时存在的</li><li>程序和进程存在的实体不同。程序是指令的集合，进程是由正文段、用户数据段、进程控制块组成</li></ol><h1 id="三、进程与程序的关系"><a href="#三、进程与程序的关系" class="headerlink" title="三、进程与程序的关系"></a>三、进程与程序的关系</h1><p>进程是程序的一次执行，进程总是对于一个特定的程序，一个程序可以对于多个进程</p><h1 id="四、进程的组成部分"><a href="#四、进程的组成部分" class="headerlink" title="四、进程的组成部分"></a>四、进程的组成部分</h1><h2 id="正文段"><a href="#正文段" class="headerlink" title="正文段"></a>正文段</h2><p>正文段存放被执行的激情指令</p><h2 id="用户数据"><a href="#用户数据" class="headerlink" title="用户数据"></a>用户数据</h2><p>用户数据段存放进程在执行时要操作的用户数据</p><h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p>是操作系统管理进程所使用的数据结构<br>进程控制块是实体的一部分，是操作系统重要的数据结构，进程控制块中记录了操作系统所需要的，用户描述进程情况以及控制运行所需要的全部信息，进程控制块是操作系统感知进程存在的唯一标志。</p><h1 id="五、进程管理"><a href="#五、进程管理" class="headerlink" title="五、进程管理"></a>五、进程管理</h1><ol><li>进程的状态信息：就绪态、执行态、阻塞态</li><li>进程的组织方式：链接方式、索引方式、进程队列</li><li>进程的控制：进程的创建—阻塞—唤醒—终止</li><li>进程的创建条件：1) 用户登录 2)作业调度 3)提供服务 4)应用请求</li><li>阻塞条件： 1)请求系统服务 2)数据尚未到达 3)无工作可做 4)启动某种操作</li></ol><h2 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h2><p>操作系统内核是指系统与硬件密切相关、执行频率高的模块，一般常驻内存。</p><h3 id="操作系统内核的功能"><a href="#操作系统内核的功能" class="headerlink" title="操作系统内核的功能"></a>操作系统内核的功能</h3><ol><li><p>支持功能<br>支撑功能包括：中断处理、时钟管理和原语操作，其中原语操作是一组在执行过程中不能中断的操作</p></li><li><p>资源管理功能<br>资源管理功能包括：进程的管理、存储器管理和设备管理</p></li></ol><p>####中断</p><p>中断时改变计算机执行指令的顺序的一种事件，这种事件与cpu芯片内外部硬件电路参数的电信号对应。</p><p><strong>中断的目的</strong>：能够有效提高cpu的利用率，改善系统性能，支持系统的异步性。例如在引用中断机制之前，采用的是发福轮询的方式来检测本次I/O是否结束。</p><p><strong>中断的类型</strong>：</p><ol><li>同步中断：当指令执行时由cpu控制段元产生的，如除法出错，调试、溢出、浮点出错等</li><li>异步中断（外部中断）：是由其他硬件设备随机产生的，可分为外部可屏蔽中断（I/O设备产生）和外部不可屏蔽中断(紧急事件产生，硬件故障等)</li></ol><p><strong>引起中断的原因</strong>：1)人为设置中断 2)程序性事故 3)I/O设备 4)硬件故障 5)外部事件</p><h2 id="时钟管理"><a href="#时钟管理" class="headerlink" title="时钟管理"></a>时钟管理</h2><p>计算机很多活动都是有定时测量来控制的，两种定时测量 1) 保存当前的系统事件和日期 2)维持定时器，操作系统依靠时钟硬件和时钟驱动程序完成上述两种测量</p><p><strong>时钟硬件</strong>：按照指定时间间隔产生时钟中断，测量逝去的时间，并触发与时间有关的操作<br><strong>时钟软件</strong>：维护日期和时间，递减当前进程在一个时间片内的剩余执行时间，对cpu的使用情况记账，递减报警计算器</p><p><strong>时钟源</strong>：实时时钟（RTC/CMOS）/OS时钟</p><h2 id="系统调用与一般函数"><a href="#系统调用与一般函数" class="headerlink" title="系统调用与一般函数"></a>系统调用与一般函数</h2><p>系统调用是一群实现定义好的模块，他们提供一条管道让应用程序或用户能由此得到核心程序的服务。系统调用时系统程序与用户程序之间的接口。</p><p>系统调用与一般函数的区别：<br>1) 系统调用运行在系统态，一般函数运行在用户态<br>2) 系统调用与一般函数的执行过程不同，系统调用中断时，有系统找到对于的系统调用子程序<br>3) 系统调用要进行[中断处理],比一般函数多一些系统开销</p><h2 id="进程同步："><a href="#进程同步：" class="headerlink" title="进程同步："></a>进程同步：</h2><p>操作系统同步机制的主要任务就是保证在多任务共享系统资源的情况下，程序能够得到正确的结果。同时，同步机制需要解决进程执行的协调问题。</p><p>进程同步有两个作用</p><ol><li>对具有共享资源的进程，保住以互斥的方式访问临界资源。临界资源必须以互斥的方式访问共享资源</li><li>对具有相互合作关系的进程，要保证相互合作的各个进程协调执行</li></ol><p><strong>同步机制遵循的准则</strong>： 1)空闲让进 2)忙则等待 3)有限等待 4) 让权等待</p><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p>信号量机制对不同共享资源设置称之为信号量的变量，用信号量的取值标识资源的使用情况，或某种事件的发生</p><h3 id="整形信号量机制"><a href="#整形信号量机制" class="headerlink" title="整形信号量机制"></a>整形信号量机制</h3><p>用整形来标记资源的使用情况。若整形量&gt;0,说明有资源可用；若整形量&lt;=0，说明资源忙，进程必须等待。</p><h3 id="记录型信号量机制"><a href="#记录型信号量机制" class="headerlink" title="记录型信号量机制"></a>记录型信号量机制</h3><p>除了用整形来标记资源的使用情况外，额外使用一个记录进程队列来存储等待资源的进程。这样就不存在“忙等”，而是通过有可用资源时的回调触发</p><h3 id="AND型信号量的机制"><a href="#AND型信号量的机制" class="headerlink" title="AND型信号量的机制"></a>AND型信号量的机制</h3><p>基本思想是将进程在整个运行过程中所需要的所有资源一次性的全部分配给进程，待进程使用完后再一起释放。</p><h1 id="六、线程"><a href="#六、线程" class="headerlink" title="六、线程"></a>六、线程</h1><p>在操作系统中，进程是进行资源分配和独立执行的基本单位，为了进一步提高程序的并发性，减少系统的开销，在操作系统中引入了线程的概念。<br>线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程在运行中断性，也有就绪、执行、阻塞三种状态。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/cao-zuo-xi-tong-yuan-li-chu-shi-cao-zuo-xi-tong/"/>
      <url>/cao-zuo-xi-tong-yuan-li-chu-shi-cao-zuo-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><p>  操作系统是提供计算机用不与计算机硬件之间的使用接口，并能够管理计算机软件和硬件资源的一个复杂的系统软件，为用户的应用程序提供直接可用的运行环境，是应用程序的开发变得简单、高效。<br>  试想一下如果没有操作系统，你将怎样写代码？<br>  例如你要写一个实现<code>printf(&quot;hello world&quot;)</code>的功能，你要怎么实现呢？<br>  无操作系统的环境下，你只能使用汇编语言直接操作硬件接口</p><pre><code>  xor ah,ah;//对ah、dl清零  xor dl,dl;//软驱复位  int13h;//BIOS功能调用int 13h中断  ... //此处省略n行代码  mov cl,ah;//其实扇区号送cl寄存器  mov dh,al;</code></pre><p>  可以看出一个简单的功能，要实现一大段的代码，并且没有的计算机资源做统一的管理，极大的降低程序运行的效率和开发效率。</p><h1 id="操作系统的发展历史"><a href="#操作系统的发展历史" class="headerlink" title="操作系统的发展历史"></a>操作系统的发展历史</h1><h2 id="无操作系统时代"><a href="#无操作系统时代" class="headerlink" title="无操作系统时代"></a>无操作系统时代</h2><p>第一代计算机（1945~1955年）使用电子管作为主要电子器件，用插件版的链接先或穿孔片表示程序，没有用来存储程序的内存，无操作系统的。<br>我们熟知的那个庞然大物——人类第一台计算机”艾尼阿克”（ENIAC）就是这样的计算机，最初只能完成5000每秒的计算，耗电量在150千万每小时。程序的编程只能通过改变电路的链接方式来表示不同的算法，程序的运行与退出都需要人工的干预，这就是我们人类最初的计算机<br><img src="https://leanote.com/api/file/getImage?fileId=5ce16d88ab64414b37003427" alt></p><h2 id="单道批量处理计算机"><a href="#单道批量处理计算机" class="headerlink" title="单道批量处理计算机"></a>单道批量处理计算机</h2><p>从第一代计算机开始大概经过了10年的发展，开始使用磁性存储设备，程序员在磁带上录入多批次的作业，交给计算机操作人员，放入计算机中批量载入计算机，计算机会一个一个计算并将结果输出到另外一个磁性设备。这一时期的操作系统就是单到批处理系统，内存红能主流移到用户作业，cup和内存资源被用户作业独占。程序是指令的集合，程序执行是cpu的依次、逐条执行指令的过程。相比于上一代计算机，减少了等待人工操作的时间，但是作业进行I/O时，CPU只能等待I/O完成而无事可做，cpu资源得不到充分利用</p><h2 id="多道批处理系统的特点"><a href="#多道批处理系统的特点" class="headerlink" title="多道批处理系统的特点"></a>多道批处理系统的特点</h2><p>为了解决上一代计算机的问题，有发展到了多道批处理系统。<br>与单道批处理系统相比，躲到批处理系统支持多道程序驻留内存，cpu不在因为某个进程等待I/O而空闲，而是可以去执行其他进程。</p><h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><p>分时操作系统运行多个用户通过终端同时使用计算机。分时操作系统需要解决的两个关键问题是及时接收和及时处理。分时操作系统为例保证每个用户终端的相应时间，使所有的用户任务直接进入内存，并在很短的时间内快速切换让每个任务都运行一遍，达到多个用户任务并行处理的目的。</p><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>实时操作系统主要用户实时控制和实时信息处理领域。与分时系统相比，它具有多路性、独立性、及时性、交互性、可靠性几个特点。<br>实时系统比分时系统要求有更高的可靠性，必须能够在任务能够容忍的时间范围内处理完，否则可能带来巨大的经济损失设置生命安全。批处理系统、分时系统和实时系统是三种基本的草鞋系统类型，实时操作系统可能兼有三者货主其中两者的功能特征.</p><p>#操作系统的五大功能</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存管理主要是为多道程序运行提供良好的环境，方便用户使用内存，提高内存的利用率，已经从逻辑上扩充内存以实现虚拟存储。包括内存分配、内存保护、地址映射、内存扩充功能。</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>内存分配可分为静态分配和动态分配，静态是指按程序所需分配固定大小后不再变化，动态分配是指在系统运行中，根据进程的骑牛分配内存大小，是可以在运行时变化的。<br>为了实现内存分配，需要实现以下几个功能：</p><ol><li>适用于内存分配的数据结构，包含内存的使用情况，内存的空闲区大小，空闲区的起始地址，未内存分配实现提供依据。</li><li>内存分配功能。系统安装一定的内存分配算法分配内存空间。</li><li>内存回收。系统需要回收被释放的内存空间。</li></ol><h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>内存保护的任务：一是是操作系统内核的空间不会被用户随意访问，以保证系统的稳定安全。二是是没道用户程序都在自己的内存空间中运行，相对独立互不干扰。</p><h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><p>cpu执行程序的过程中，需要把程序的逻辑地址转变成物理地址，这个转换过程称为地址映射。</p><p>逻辑地址：是指一个程序编译后，通常会形成若干个目标程序，这些程序再经过链接而形成可装载的程序。这些程序中的指令和数据的地址都是相对于编译链接后的机器代码程序的起始地址计算的。称之为逻辑地址。</p><h3 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h3><p>为了满足程序的更大内存需求，就要为其从逻辑上扩充更大的内存，需要实现以下功能：</p><ol><li>请求调入功能。运行系统在装入一部分用户程序是就启动该程序的运行，若在程序运行过程中发现要执行的指令货主要访问的数据没有载入内存，通过请求调入装入内存。</li><li>置换功能。在请求调入是，若发现内存空间不足，需要系统将内存中一部分内存换到外存中，以便腾出内存空间载入当前需要的内容。</li></ol><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程管理主要包括：经常的组织和描述、进程的控制、进程的同步、进程同学及进程调度。例如进程的创建、销毁、唤醒、阻塞等操作。</p><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><p>设备管理主要完成用户的I/O请求，未用户分配I/O设备。为了完成这些任务，设备管理需要具备以下功能：</p><ol><li>缓冲管理。</li><li>设备分配。分配用户I/O所需的设备。</li><li>设备处理。由设备驱动程序来实现cpu与设备控制之间的通讯。</li><li>设备独立性和虚拟设备。设备独立性功能是应用程序独立于物理设备。例如，用高级程序设计语言打印图形程序。</li></ol><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>文件存储空间的管理、文件目录的管理、文件读写</p><h2 id="提供用户接口"><a href="#提供用户接口" class="headerlink" title="提供用户接口"></a>提供用户接口</h2><p>为了方便用户使用操作系统，操作系统向用户提供命令行和图形用户接口，向程序员提供应用程序与操作系统之间的接口。</p><h1 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h1><p>操作系统的体系结构是一个复杂软件系统的高层结构，未软件系统提供了一个结构、行为和属性的高级抽象，包括系统元素的结构、元素拣的相互关系，以及指导元素集成的模式和约束。</p><h2 id="简单的监控程序模型"><a href="#简单的监控程序模型" class="headerlink" title="简单的监控程序模型"></a>简单的监控程序模型</h2><p>最初的计算机并不存在操作系统这个概念，所有的任务都是直接运行与硬件上，程序员直接操作硬件系统。随着控制语言的出现，产生了简单的监控程序，能够保证任意时刻系统只能运行一个任务，保证对系统信息的互斥访问。</p><h2 id="单体结构模型"><a href="#单体结构模型" class="headerlink" title="单体结构模型"></a>单体结构模型</h2><p>在单体结构模型中，多有的软件和数据结构防止在一个逻辑模块中，对外出的用户程序提供一个完成的内核界面——系统调用。整个系统有若干个功能独立的子程序组成，运行任意一子程序调用其他子程序，因此它的特点是结构简单，便于理解和实现，而且系统所有的部分都集中在一个内核中，效期较高，缺点也很明显，各个子程序之间可以相互调用，系统结构关系复杂，容易引起循环调用和死锁。</p><h2 id="层次结构模型"><a href="#层次结构模型" class="headerlink" title="层次结构模型"></a>层次结构模型</h2><p>层次结构的基本思想是讲操作系统分解为多个晓得容易理解的层，系统功能被隔离在不同的层中，每一层提供对系统功能的部分抽象。在操作系统的层次结构中，各个模块都有相对固定的位置、相对固定的层次。层与层之间有间隔的接口定义，每一次值依赖于它下层提供的服务而工作，不能夸层随意访问。不过出于效率的考虑，有些系统运行夸层乡下调用。</p><h2 id="客户-服务器模型与微内核结构"><a href="#客户-服务器模型与微内核结构" class="headerlink" title="客户/服务器模型与微内核结构"></a>客户/服务器模型与微内核结构</h2><p>它的核心思想是功能外迁，即吧传统操作系统内核中的一些组成部分（如文件系统、网络、驱动程序等内核功能）放到内核之外作为一个独立的服务进程来实现，在微内核中只保留了操作系统最基本的功能，包括处理器调度、存储管理和消息通道等。</p><h2 id="动态可扩展结构模型"><a href="#动态可扩展结构模型" class="headerlink" title="动态可扩展结构模型"></a>动态可扩展结构模型</h2><p>采用UPCALL和DOWNLOAD技术。它试图将所有的传统操作系统内核中提供的抽象转移到用户控件，以操作系统库的形式提供服务，内核层只负责对物理设备的控制。应用程序可以从用户层库中得到并控件内核抽象，从而实现了操作系统的动态扩展。</p><h1 id="指令的执行"><a href="#指令的执行" class="headerlink" title="指令的执行"></a>指令的执行</h1><h2 id="取指令和执行指令"><a href="#取指令和执行指令" class="headerlink" title="取指令和执行指令"></a>取指令和执行指令</h2><ol><li>取指令，在每个指令周期开会时，处理器从存储器中读取一条指令，在典型的固定长度指令处理器中，程序计数器（PC）保存有下一次要取的指令地址，每次取指令后都对PC作递增，使它能够按顺序读取吓一条指令，即位于下一个高端存储器地址的指令。</li><li>执行指令，取到指令被防止在处理器的指令寄存器IR中。指令中包含确定处理器将要采取动作的位，处理器解释指令并执行要求的动作，这些动作可分为4类：</li><li>1 处理器与存储器之间的指令或数据传送操作。</li><li>2 处理器与I/O设备质检的指令或数据传送操作</li><li>3 算数运算操作或逻辑运算操作</li><li>4 控制操作，即修改指令的执行顺序的操作。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>程序执行过程是反复取指令和执行指令的过程。PC使用存有下一条指令的地址。指令的执行结果就是使寄存器或内存单元的值发生变化，指令执行的过程也就是存储体内容不断变化的过程。取指令和执行指令是有硬件完成的，不同硬件的体系结构支持不同的指令集合，为某一种硬件平台开发的操作系统不能直接在另外一中体系结构的硬件上运行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/cong-ling-kai-shi-shi-yong-solidity-bian-xie-yi-tai-fang-zhi-neng-he-yue-bing-shi-yong-nodejs-sdk-fang-wen-yi-tai-fang-wang-luo/"/>
      <url>/cong-ling-kai-shi-shi-yong-solidity-bian-xie-yi-tai-fang-zhi-neng-he-yue-bing-shi-yong-nodejs-sdk-fang-wen-yi-tai-fang-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="Nodejs安装"><a href="#Nodejs安装" class="headerlink" title="Nodejs安装"></a>Nodejs安装</h1><p>Nodejs 版本建议8.0以上<br>官网：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a><br>官网下载安装包:<a href="https://nodejs.org/dist/v8.12.0/node-v8.12.0-x64.msi" target="_blank" rel="noopener">https://nodejs.org/dist/v8.12.0/node-v8.12.0-x64.msi</a><br>安装参考：<a href="https://blog.csdn.net/qq_26562641/article/details/72235585" target="_blank" rel="noopener">https://blog.csdn.net/qq_26562641/article/details/72235585</a></p><p>配置淘宝镜像：</p><pre><code>npm config set registry https://registry.npm.taobao.org</code></pre><h1 id="新建一个Hello-World只能合约的访问"><a href="#新建一个Hello-World只能合约的访问" class="headerlink" title="新建一个Hello World只能合约的访问"></a>新建一个Hello World只能合约的访问</h1><ol><li><p>使用IDEA安装nodejs插件，在插件列表搜索</p></li><li><p>新建一个node工程项目，File&gt;New Project 选择Node.js and NPM<br><img src="../images/%E6%9C%AA%E5%91%BD%E5%90%8D/getImage-20220825155544126.png" alt><br>默认有很多其他的目录，我们删除其他目录，只保留如下的目录：<br><img src="../images/%E6%9C%AA%E5%91%BD%E5%90%8D/getImage-20220825155543961.png" alt><br>或者使用<code>npm init</code>命令初始化一个nodejs工程</p></li><li><p>安装solidity编译器依赖，用于编译Solidity，才能被nodejs使用到</p><pre><code>npm install --save solc</code></pre></li><li><p>安装以太坊的访问SDK web3.js</p><pre><code> npm install --save web3</code></pre><p> 报错解决：</p><blockquote><ol><li>报<code>gyp ERR! configure errorgyp ERR! stack Error: Command failed: C:\Users\yan6\AppData\Local\Programs\Python\Python37-32\python.EXE -c import sys; print &quot;%s.%s.%s&quot; % sys.version_info[:3];</code><br>原因：安装脚本中用到了Python2的语法，你的环境变量中配置的Python3所以报这个错<br>解决：修改python的环境变量，将Python3改成Python2，如果没有到官网下载一个Python2</li><li>报<code>error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1)</code><pre><code>MSBUILD : error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1) 安装 .NET Framework 2.0 SDK；2) 安装 Microsoft VisualStudio 2005；或 3) 如果将该组件安装到了其他位置，请将其位置添加到系统路径中。 [D:\workspace\idea_workspace\blockchian1\node_modules\scrypt\build\binding.sln]MSBUILD : error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1) 安装 .NET Framework 2.0 SDK；2) 安装 Microsoft VisualStudio 2005；或 3) 如果将该组件安装到了其他位置，请将其位置添加到系统路径中。 [D:\workspace\idea_workspace\blockchian1\node_modules\scrypt\build\binding.sln]</code></pre>解决办法,按装全局windows相关组件：<pre><code>npm install --global --production windows-build-tools </code></pre></li></ol></blockquote></li><li><p>安装ganache,ganache是用来在本地测试用的测试以太坊网络</p><pre><code> npm install -g ganache-cli</code></pre></li><li><p>新建一个Solidity脚本，<code>Hello.sol</code></p><pre><code> pragma solidity ^0.4.17; contract Hello {     string public name;     function Hello(string _name) public {         name = _name;     }     function setName(string _name) public {         name = _name;     }     function getName() public view returns(string ) {         return name;     } }</code></pre></li><li><p>编写一个solidity的编译脚本compile.js</p><pre><code> const path = require(&#39;path&#39;); const  fs = require(&#39;fs&#39;); const solc = require(&#39;solc&#39;); const srcpath = path.resolve(__dirname,&#39;contracts&#39;, &#39;Hello.sol&#39;); const source = fs.readFileSync(srcpath, &#39;utf-8&#39;); //console.log(source); const result = solc.compile(source,1); //console.log(result); module.exports = result.contracts[&#39;:Hello&#39;];</code></pre></li><li><p>在tests下新建一个本地Hello World测试类,<code>Web3Test.test.js</code></p><pre><code> const  assert = require(&#39;assert&#39;); //约定规范，如果变量是大写 const Web3 = require(&#39;web3&#39;); //内存里面的以太坊测试环境 const  ganache = require(&#39;ganache-cli&#39;); const web3 = new Web3(ganache.provider()); //执行编译脚本，并将编译结果引入进来 const {interface,bytecode} = require(&#39;../compile&#39;); /**  * 测试一个Hello World智能合约  * @returns {Promise.&lt;void&gt;}  */ testGetSet = async ()=&gt; {     let accounts = await web3.eth.getAccounts();     //部署也是一个交易命令，所以需要花gas     const abi = JSON.parse(interface);     const contract = new web3.eth.Contract(abi);     const result = await contract.deploy({         data:bytecode,         arguments:[&#39;Hello World&#39;]     }).send({         from:accounts[0],         gas: 1500000,         gasPrice: &#39;30000&#39;     });     console.log(&#39;deploy success:&#39; + result.options.address);     //测试查询     assert.equal(await result.methods.getName().call(),&#39;Hello World&#39;);     await result.methods.setName(&#39;hahaha&#39;).send({         from:accounts[0],         gas:100000     });     assert.equal(await result.methods.getName().call(),&#39;hahaha&#39;);     console.log(&#39;测试智能合约成功&#39;); }</code></pre></li></ol><pre><code>/** * 测试以太坊转账 * @returns {Promise.&lt;void&gt;} */testTrade = async ()=&gt; {    let accounts = await web3.eth.getAccounts();    let b0 = await web3.eth.getBalance(accounts[0]);    let b1 = await web3.eth.getBalance(accounts[1]);    //发送交易    console.log(&#39;开始转账：account0:&#39; + b0 + &#39; account1:&#39; + b1);    await web3.eth.sendTransaction({        from:accounts[0],        to:accounts[1],        value:&#39;1000000000000000&#39;    });    b0 = await web3.eth.getBalance(accounts[0]);    b1 = await web3.eth.getBalance(accounts[1]);    //发送交易    console.log(&#39;转账成功：account0:&#39; + b0 + &#39; account1:&#39; + b1);}testGetSet();testTrade();```</code></pre><blockquote><p>以上代码<code>const {interface,bytecode} = require(&#39;../compile&#39;);</code><br>这句话的意思是将Hello.sol编译后的导入到当前的node上下文，interface就是编译后的一些方法定义，bytecode就是最终部署到以太坊网络的二进制数据</p></blockquote><ol start="9"><li>测试运行<pre><code> node `Web3Test.test.js</code></pre> 运行结果：<br> <img src="../images/%E6%9C%AA%E5%91%BD%E5%90%8D/getImage-20220825155544126-1414144.png" alt></li></ol><h1 id="将代码提交到以太坊rankeby测试网络"><a href="#将代码提交到以太坊rankeby测试网络" class="headerlink" title="将代码提交到以太坊rankeby测试网络"></a>将代码提交到以太坊rankeby测试网络</h1><ol><li><p>安装truffle-hdwallet-provider<br>组件官方文档：<a href="https://www.npmjs.com/package/truffle-hdwallet-provider" target="_blank" rel="noopener">https://www.npmjs.com/package/truffle-hdwallet-provider</a></p><pre><code>  npm install truffle-hdwallet-provider</code></pre></li><li><p>使用truffle-hdwallet-provider：</p><pre><code> //线上的测试环境 var HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;); var mnemonic = &quot;这里是你的以太坊钱包私钥助记词&quot;; // 12 word mnemonic //使用infura在线的provider var provider = new HDWalletProvider(mnemonic, &quot;https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5&quot;); const web3 = new Web3(provider);</code></pre><blockquote><p>上面用到的provider_url：<a href="https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5是infura的在线url,到https://rinkeby.infura.io注册一个账号并添加一个rinkeby的测试PROJECT就可以得到一个测试provider_url了，网络不好可能需要翻墙" target="_blank" rel="noopener">https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5是infura的在线url,到https://rinkeby.infura.io注册一个账号并添加一个rinkeby的测试PROJECT就可以得到一个测试provider_url了，网络不好可能需要翻墙</a></p></blockquote></li><li><p>新增一个测试代码进行测试交易,<code>EtherOnlieRinkebyTest.test.js</code></p><pre><code> //约定规范，如果变量是大写 const Web3 = require(&#39;web3&#39;); //线上的测试环境 var HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;); var mnemonic = &quot;这里是你的以太坊钱包私钥助记词&quot;; // 12 word mnemonic //使用infura在线的provider var provider = new HDWalletProvider(mnemonic, &quot;https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5&quot;); const web3 = new Web3(provider); /**  * 测试web3  */ testSend = async ()=&gt; {         let accounts = await web3.eth.getAccounts();         console.log(accounts);         let account0 = accounts[0];         let account1 = &#39;0x5828eb46D40795Da76429553845DfA622F062CB2&#39;;         let b0 = await web3.eth.getBalance(account0);         let b1 = await web3.eth.getBalance(account1);         console.log(&#39;开始转账：address0:&#39; + account0 + &#39; :&#39; + b0 + &#39; address1:&#39;+account1 + &#39; account1:&#39; + b1);         const tx = web3.eth.sendTransaction({             from:account0,             to:account1,             value: web3.utils.toWei(&#39;1&#39;, &#39;ether&#39;),             data: web3.utils.toHex(&#39;I love you ,xiao man ju&#39;)         },async (err,address)=&gt;  {             console.log(&quot;转账成功,address:&quot; + address);             b0 = await web3.eth.getBalance(account0);             b1 = await web3.eth.getBalance(account1);             let tx = await web3.eth.getTransaction(address);             console.log(&#39;tx:&#39;+ JSON.stringify(tx) +&#39; 转账成功：address0:&#39;+account0+&#39;:&#39; + b0 + &#39; address1:&#39;+account1+&#39; account1:&#39; + b1);         });        } testSend();</code></pre></li><li><p>使用nodejs运行测试代码</p><pre><code> node EtherOnlieRinkebyTest.test.js</code></pre><p> 输出结果如下：<br> <img src="../images/%E6%9C%AA%E5%91%BD%E5%90%8D/getImage-20220825155544225.png" alt></p></li></ol><p>到此从开发到上传到访问以太坊rinkeby测试网络已经完成。</p><h1 id="Nodejs测试框架"><a href="#Nodejs测试框架" class="headerlink" title="Nodejs测试框架"></a>Nodejs测试框架</h1><p>上面我们测试一个node脚本是直接使用node命令直接运行，对于实际开发应用中如果想做到自动化测试用例的运行，需要用到类型java里面Junit测试框架的东西，这个东西在node里面叫Mocha</p><ol><li><p>安装mocha</p><pre><code> npm install --save mocha</code></pre></li><li><p>修改<code>package.json</code>，将scripts.test改成<code>mocha</code></p><pre><code> {   &quot;name&quot;: &quot;blockchian1&quot;,   &quot;version&quot;: &quot;1.0.0&quot;,   &quot;description&quot;: &quot;&quot;,   &quot;main&quot;: &quot;app.js&quot;,   &quot;directories&quot;: {     &quot;test&quot;: &quot;test&quot;   },   &quot;dependencies&quot;: {     &quot;mocha&quot;: &quot;^5.2.0&quot;,     &quot;solc&quot;: &quot;^0.4.25&quot;   },   &quot;devDependencies&quot;: {},   &quot;scripts&quot;: {     &quot;test&quot;: &quot;mocha&quot;   },   &quot;author&quot;: &quot;&quot;,   &quot;license&quot;: &quot;ISC&quot; }</code></pre><blockquote><p>配置了scripts.test 为mocha命令，<code>npm run test</code>访问的就是mocha的测框架</p></blockquote></li><li><p>mocha测试，<code>MochaTest.test.js</code>, describe就是基本的mocha测试骨架，it是测试用例</p><pre><code> const assert = require(&#39;assert&#39;); /**  * ecs6 mocha测试  */ class Test {     say() {         return &#39;hello&#39;;     }     happy() {         return &#39;haha&#39;;     } } //开始写mocha测试框架 let dog; beforeEach(()=&gt;{     dog = new Test(); }) describe(&#39;第一个mocha测试用例&#39;,()=&gt; {     it(&#39;测试hello()&#39;,()=&gt;{         //const  dog = new Test();         let say = dog.say();         console.log(say);         assert.equal(say,&#39;hello&#39;);     })     it(&#39;测试happy()&#39;,()=&gt;{         let happy = dog.happy();         console.log(happy);         assert.equal(happy,&#39;haha&#39;);     }) })</code></pre><blockquote><p>以上用到了assert组件，这个类似java里面的Assert断言，默认在node上下文已将安装，直接依赖使用即可</p></blockquote></li><li><p>运行测试用例</p><pre><code> npm run test</code></pre><p> 这个test访问的就是我们之前修改的<code>package.json</code>里面的test命令mocha，类似maven构建时的测试，它将运行项目上下文中的所有实现了mocha的测试用例</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>系统架构师——软件开发方法</title>
      <link href="/ruan-jian-kai-fa-fang-fa/"/>
      <url>/ruan-jian-kai-fa-fang-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：软件开发方法是软件开发的方法学，旨在提供软件的质量，降低开发成本</p></blockquote><h1 id="1-软件生命周期"><a href="#1-软件生命周期" class="headerlink" title="1 软件生命周期"></a>1 软件生命周期</h1><ol><li>可行性研究和规划：通过可行性分析确认原件的必要性，价值点，初步确认软件的目标、范围、风险和开发成本等内容。</li><li>需求分析：需求分析是开发过程的重要阶段，初步确认软件开发的目标和范围，之后则要对软件的需求进行细致分析，确认最终要做成什么样子。这个过程极其重要，如果这个阶段出现分析错误和偏差将导致后续开发过程偏离真实需求越远，修正的成本越大。</li><li>概要设计：是程序员开发过程中的蓝图，包括确认系统架构、各个子系统依赖关系、数据库模型、编码规范、接口规约等内容</li><li>详细设计：详细设计师开发之前的最后设计，是在概要设计的基础上进行进行细化，如类设计。详细设计不是必要过程，在规模较小，功能结构简单的系统中可以省略。</li><li>实现：针对设计的单元模块进行开发，如一个过程、方法、函数，包括实现单元模块的单元测试</li><li>集成测试：对单元模块进行组装联调测试</li><li>确认测试：系统开发完后，需要验证是否和需求预期一致</li><li>软件使用和维护：软件投入试运行，并不断对过程中出现的问题进行维护修正，软件维护郭晨会贯穿整个软件的使用郭晨直至软件自然消亡。</li></ol><h1 id="2-软件开发模型"><a href="#2-软件开发模型" class="headerlink" title="2 软件开发模型"></a>2 软件开发模型</h1><p>计算机刚刚诞生的年代，是一种只有天才才能掌握的巩固，人们对软件知识的认知仅仅停留在程序层面。随着技术发展，软件复杂度的提高，意识到必须遵循一定的开发方法才能取得成功，于是出现了模式化的开发方法称为开发模型。</p><h2 id="2-1-瀑布模型"><a href="#2-1-瀑布模型" class="headerlink" title="2.1 瀑布模型"></a>2.1 瀑布模型</h2><p>特点：</p><ol><li>软件过程要经过需求分析、总体设计、详细设计、编码、调试、集成测试和系统测试阶段，开发阶段划分明确</li><li>再每一个阶段结算后都有不定的文档或者程序流入下一个阶段</li><li>每个阶段在发现问题时可以反馈给上一个阶段进行修正<br>适用场景：需求明确、稳定时</li></ol><h3 id="2-1-1-瀑布V模型"><a href="#2-1-1-瀑布V模型" class="headerlink" title="2.1.1 瀑布V模型"></a>2.1.1 瀑布V模型</h3><p>同标准瀑布模型一样，保持了瀑布模型的阶段式文档驱动的特点，但是更强调软件产品的验证工作，即需求分析的记过将作为系统测试的标准，能够在设计初期得到验证，以此类推，总体设计对应了集成测试，详细设计对应了单元测试。</p><h3 id="2-1-2-瀑布模型的缺点"><a href="#2-1-2-瀑布模型的缺点" class="headerlink" title="2.1.2 瀑布模型的缺点"></a>2.1.2 瀑布模型的缺点</h3><ol><li>需求分析是一切活动的基础，如果需求分析出现偏差，将导致后续活动放大这个偏差。但事实是，由于用户、开发者立场、经验不同、知识领域不同，对同一事物的表述不同造成的理解偏差难于避免，导致后期维护工作繁重</li><li>难于适应需求变化，一旦需求变更要重头再来</li><li>从需求提出到最后看到产品是一个相当长的过程，不能及时给用户反馈，并验证是否是能够满足客户需求的软件。</li><li>瀑布模型是面向文档的开发模型，过程中将产生大量文档，大部分对客户没有意义，但却工作量繁重</li></ol><h2 id="2-2-演化模型"><a href="#2-2-演化模型" class="headerlink" title="2.2 演化模型"></a>2.2 演化模型</h2><p>演化模型是在瀑布模型难以一次性完全理解用户需求的基础上，对整个过程进行若干次的“瀑布模型”迭代，做到不断渐进、不断深入的过程</p><h2 id="2-3-螺旋模型"><a href="#2-3-螺旋模型" class="headerlink" title="2.3 螺旋模型"></a>2.3 螺旋模型</h2><p>螺旋模型是在瀑布模型和演化模型结合的基础上，还强调其他模型忽略的风险分析。<br>特点：</p><ol><li>螺旋模型对每一期都包含需求定义、风险分析、工程实现、和评审4个阶段，对整个过程进行螺旋式迭代</li><li>支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供方便，降低软件开发风险</li></ol><p>缺点：</p><ol><li>螺旋模型的风险评估需要具有丰富风险评估经验和专业知识的人，否则将造成重大损失</li><li>过多的迭代次数会增加开发成本，延迟提交时间</li></ol><h2 id="2-4-增量模型"><a href="#2-4-增量模型" class="headerlink" title="2.4 增量模型"></a>2.4 增量模型</h2><p>演化模型是另外一种增量模型的形式。在系统架构成熟、风险较低时，可采用增量方式进行系统开发，可提前进行基础测试和系统测试，缩短出事版本的发布周期，提高用户对系统的可见度。<br>特点：</p><ol><li>增量模型，做好系统的分析和设计，对系统划分为若干不同的版本，每一个版本都是完成可用的系统，后一个版本是前一个版本的基础进行开发，扩展前一个版本的功能，同时保证每个版本增量均匀。</li><li>原型法，每一次发布都经历完成的生命周期，当用户需求很多不明确或者技术架构中很多不可知因素时，可采用原型增量法。在初始版本的原型并不考虑需求的合理性和系统稳定性，只为精准获取用户需求，一般会在后面的开发中抛弃这个原型进行完成的系统实现。</li></ol><h2 id="2-5-构件组装模型"><a href="#2-5-构件组装模型" class="headerlink" title="2.5 构件组装模型"></a>2.5 构件组装模型</h2><p>将系统划分为一组构件的集合，明确构件之间的关系。每个构件可以独立开发、自包容，可以是自己开发设计，也可以是第三方购买整合。最后进行构件组装的一个开发模型。<br>构件组装优点：</p><ol><li>构件自包容让系统扩展变得更加容易</li><li>良好的构件更容易重用，降低开发成本</li><li>构件力度较整个系统更小，更容易开发设计及安排工作更加灵活</li></ol><p>缺点：</p><ol><li>对构件设计需要经验丰富的架构设计师，设计不良的构件难以实现他的优点</li><li>考虑重用度是，往往会对其他方面设计做出让步，比如性能</li><li>构件组装应用是，要求程序员熟悉掌握构件，增加了开发人员的学习成本</li><li>第三方构件质量难以把控，将影响软件的质量。</li></ol><h1 id="3-统一过程模型"><a href="#3-统一过程模型" class="headerlink" title="3 统一过程模型"></a>3 统一过程模型</h1><p>统一过程（Unified Process, UP）是一种优秀的软件开发模型，可以有效地降低软件开发过程中的风险。这个开发模型的特点是每一个阶段的工作都不是绝对的，都是相互交叠配的的，但是每一个阶段都有侧重点。</p><p><img src="leanote://file/getImage?fileId=5eaa43af605ce63a32000003" alt></p><p>整个过程大致分为</p><ol><li>初始阶段，刚刚接入系统开发工作，侧重工作是明确系统目的，业务建模和需求工作</li><li>细化阶段，抽象软件逻辑模型，设计架构，侧重是分析设计工作</li><li>构件阶段，完成系统的构件，使之成为一个完整的实体，并进行测试和部署</li><li>交付阶段，软件系统需求已经完成，重点工作是对软件进行重构、修改、测试和部署</li></ol><p>整个工作内容整体包括：业务建模、需求、分析设计、实施、测试、部署、配置与变更管理、项目管理、环境。</p><p>其中“环境”是相对于其他工作难以理解的。环境工作很重要，也称之为环境管理。在软件开发过程中，需要为各种工作准备相应的工作环境，在工作环境中包含必须的工具、活动指南、活动流程规范、工作产品模板、基本的开发设施等。环境管理应该在工作流中得到应有的重视，每个开发团队都有自己的特点和活动准则规范，这种准则和规范是团队协作的基础，万万不能少，否则开发活动就会使放养式的管理。</p><p>** UP的生命周期**<br>分为4个里程碑</p><ol><li>目标里程碑。明确系统的目标和范围时达到这个里程</li><li>架构里程碑。当开发者确定稳定系统的架构时达到这个里程</li><li>能力里程碑。当系统已经足够稳定和成熟并完成了Alpha测试之后达到这个里程碑</li><li>发布里程碑。当完成系统的测试、完成系统的发布和用户培训工作之后达到这个里程碑</li></ol><p>UP的特点：</p><ol><li>UP是一个迭代的二维开发模型，每个生命后期都可以进行需求、设计、开发等</li><li>采用不同的迭代方式的UP可以演变为演化模型或增量模型</li><li>UP的迭代特点使得更容易控制开发风险</li><li>Up是迭代开发模型，但不属于敏捷开发模型。一般未经过裁剪的Up是一个重载过程</li><li>实际应用可根据具体问题进行UP的裁剪，从而使用各种规模的软件和开发团队</li></ol><p>架构师在UP活动中的作用<br>架构师除了需要建立系统的架构模型外，在UP活动中承担非常重要的角色，例如：</p><ol><li>同需求人员和项目管理人员密切协作</li><li>细化软件架构</li><li>保持整个架构的概念完整性，具体地说就是定义设计方法、设计指南、编码规范、平舌工作</li></ol><p><strong>因此有人称UP是一个已加购书为中心的开发模型。</strong></p><h1 id="4-敏捷开发方法"><a href="#4-敏捷开发方法" class="headerlink" title="4 敏捷开发方法"></a>4 敏捷开发方法</h1><p>2001年，17位“无政府主义者”共同发表了《敏捷软件开发宣言》：</p><blockquote><ol><li>尽早地、持续地向客户交付有价值的软件对开发人员来说是最重要的。</li><li>拥抱变化，即使在开发的后期。敏捷过程能够驾驭变化，保持客户的竞争力。</li><li>经常交付可工作的软件，从几周到几个月，时间范围越小越好。</li><li>在整个项目中，业务人员和开发者紧密合作。</li><li>围绕士气高昂的团队进行开发，为团队成员提供适宜的环境，满足他们的需要，并给予<br>足够的信任。</li><li>在团队中，最有效率的、也是效果最好的沟通方式是面对面地交流。</li><li>可以工作的软件是进度首要的度量方式。</li><li>可持续地开发。投资人、开发团队和用户应该保持固定的节奏。</li><li>不断追求优秀的技术和良好的设计有助于提高敏捷性。</li><li>要简单，尽可能减少工作量。减少工作量的艺术是非常重要的。</li><li>最好的架构、需求和设计都来自于一个自我组织的团队。</li><li>团队要定期地总结如何能够更有效率，然后相应地自我调整</li></ol></blockquote><p>这份宣言就是敏捷开发方法的灯塔</p><h2 id="4-1-敏捷开发方法实践之极限编程（eXtreme-Programming）"><a href="#4-1-敏捷开发方法实践之极限编程（eXtreme-Programming）" class="headerlink" title="4.1 敏捷开发方法实践之极限编程（eXtreme Programming）"></a>4.1 敏捷开发方法实践之极限编程（eXtreme Programming）</h2><p>极限编程（XP）是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方法。特点如下：</p><ol><li>在更短的周期内，更早地提供具体、持续的反馈信息。</li><li>迭代地进行计划编制。在最开始迅速形成总体计划，然后开发过程中不断迭代发展它</li><li>依赖自动化测试程序来监控开发进度，尽早地铺货缺陷</li><li>依赖口头交流、测试和源程序进行沟通</li><li>倡导持续的、演化式的设计</li><li>依赖于开发团队内部的紧密协作</li><li>尽可能达到程序员的短期利益和长期利益的平衡。即关注短期程序员的自主设计和参与感，同时帮助程序员长期的成长</li></ol><p>四大价值观：沟通、简单、反馈、勇气</p><ol><li>沟通。通常，程序员相对内向，不善言谈，项目中的许多问题都发生在缺乏良好的沟通上。而传统的开发方法中并不太在意这种口头的沟通，而是希望通过完善的流程和面面俱到的文档、报表、计划来代替，这同时就引入了效率不高的问题，往往一个小问题通过漫长的流程下来被放大。而XP方法认为，如果小组内成员无法做到持续的、无间断的交流，协作就无从谈起，XP鼓励大家进行口头的面对面交流快速解决问题，提高效率。</li><li>简单。XP方法的工作中秉承“够用即好”，实现尽可能简单化，不要过度设计。这一点看上去容易，但要做到其实很淡，因为在传统的开发过程中需要开发人员对未来做一些预先的规划，以便后续做扩展预留空间，这是一个平衡的过程，并不是一点都不考虑未来的可扩展性，所以比较难做到</li><li>反馈。传统的开发过程中缺乏对客户必要的反馈，整个开发过程像一个“黑盒子”，过程漫长，完全看不到效果和进度。容易造成最终偏离用户需求的系统软件。XP注重反馈的作用，通过持续的、明确的反馈来暴露软件当前的状态和问题，尽早地纠正一些可以避免的错误。</li><li>勇气。在XP方法中，要有勇气面对每时每刻的变化带来的挑战。由于提倡良好的沟通，会有更多的需求调整；由于提倡系统保持简单，需求变更导致的重构；由于提倡尽早反馈，更多地发现问题并纠正。而面对这些带来的挑战，我们更需要为之提高勇气。因为相比于沟通、简单和反馈带来的挑战，更多的我们是得到了良好的信息同步，尽早地发现了问题，更清晰地理解了用户需求，以及更简单地实现了系统软件。</li></ol><p>XP的四大价值观之下，隐藏着一种更深刻的东西，那就是尊重，对人的尊重。因为这一切都是建立在团队成员之间的相互关系、相互理解的基础之上。</p><h3 id="4-1-1-极限编程的十二个最佳实践"><a href="#4-1-1-极限编程的十二个最佳实践" class="headerlink" title="4.1.1 极限编程的十二个最佳实践"></a>4.1.1 极限编程的十二个最佳实践</h3><ol><li><p>计划游戏。主要思想是先快速制定一份概要计划，然后随着项目细节的不断清醒，在逐步完善这份计划。“客户负责业务决策，开发负责计算决策”，也就是说系统的范围、下一次迭代发布的时间、用户股市的优先级应有客户决定，而每个用户故事所需的而开发时间、技术成本、如何组件团队、以及开发顺序应有开发团队决定。</p><blockquote><p>计划游戏开始，客户和开发同坐一屋子，每个人准备一支笔、一些用于记录用户需求的纸片，再准备一个白板就可以开始了。</p><ol><li>客户编写需求故事：由客户谈论系统应该完成什么功能，然后用自然语言词汇写在卡片上</li><li>开发人员进行评估：有客户按优先级将故事需求标注为必须有、希望有、如果有三类，然后又开发人进行估算，优先级由高到低。如果估算的时候感到故事需求太大，不容易估算或者超过2人/周，那么应该进行分解在进行评估</li><li>确定迭代周期：根据用户期望的需求优先级、期望发布的时间结合开发现有资源与用户协商，筛检出能够实现的需求，形成初步的需求计划。</li></ol></blockquote></li><li><p>小型发布。XP方法秉承“持续集成，小步快走”的哲学思维，也就是说每次发布的版本尽可能肖，当然前提是每个版本都有发布的商业价值，值得发布。</p></li><li><p>隐喻。相对而言，隐喻这个令人费解，什么时隐喻呢，字面意思是用来暗示字面意义不相似的事物之间相似的东西。对应到开发过程中就是，需要寻求共识，对系统理解、目标价值以等；还有就是发明共享词汇，通过规范项目中常用通用的业务专有名词，减少不必要的沟通；描述体系结构；并不是每一种情况都能找到合适的隐喻，没必要强求，而是顺其自然。</p></li><li><p>简单设计。强调简单的价值观，引出简单性假设原则。这里说的简单设计并不是忽略设计而是设计不应该一次完成，因为随着业务的变化，可能当时设想的可预知的未来根本就是不存在的，留有适当的扩展设计并满足现有需求的简单设计原则。</p></li><li><p>测试先行。是指注重测试用例程序的编写，不能因为没有时间，工作紧张为由忽略测试工作，这样就会由于没有良好的测试用例而化大把的时间在后续的联调维护阶段，实际上这个整体上市大大降低产能、效率埂底下的做法。</p></li><li><p>重构。重构是一种对待吗进行重写而不影响功能实现的的技术，XP要求在开发人员“问到代码的坏味道”时，就有重构代码的勇气。重构的目的是让代码降低因变化引起的风险、使得代码更加易于维护和阅读。</p></li><li><p>结对编程。一开始虽然会牺牲一些速度，但慢慢的，开发速度会逐步加快，究其原因是结对编程大大降低了沟通成本，提高了工作的质量，具体表现在：</p><ol><li>所有的设计决策确保不是一个人做出来的</li><li>系统的任何部分至少有2个人以上熟悉</li><li>不能能同时2个人都忽略测试项</li><li>阶段的动态性，是一个去也知识管理的好途径</li><li>代码总是能够保证评审通过</li><li>XP方法集成的吉他最佳实践能够是的结对编程更加容易进行</li><li>编码标准能够消除一些无谓的分歧</li><li>隐喻可以帮助结对伙伴更好沟通</li><li>简单设计能够是的伙伴更了解他们所从事的工作</li></ol><p>结对编程技术被誉为XP保持工作质量、强调人文主义的一个典型实践，能够是的开发团队之间的协作更加流畅、知识交流更加频繁、团队更加稳定。</p></li></ol><ol start="8"><li>集体代码所有制。有XP方法鼓励团队进行结对编程，而且编程组是动态搭配的，每个人会遇到不同的代码，代码所有制就不是局限于某一个人，而是集体所有制，团队中的每个人都有进行修改的权利，每个人都拥有全部代码，也都需要对全部代码负责。同时XP强调代码是谁该坏的就应该有谁来修复。</li><li>持续集成。持续集成是最佳实践的基本支撑条件。</li><li>每周工作40小时。这是一个让开发者开心、管理者反对的一个最佳实践。加班早已成为开发人员的家常便饭，也是管理者最常用的一种策略。而XP方法认为，加班会扼杀团队的积极性，最终导致项目失败，这也体现了XP方法是关注人的因素比关注过程的因素更多一些。这里说的40小时不是绝对的额，是指根据团队公司合理的工作时长。提倡追求有效的、高效的工作时间，而不是绝对的时长。</li><li>现场客户。为了保证开发出来的结果与客户的预想接近，XP方法认为最重要的是将客户请到现场，保持和客户的现场沟通，并让客户参与到开发决策中来。</li><li>编码标准。拥有编码标准可以避免团队无关细节的争论。不过这个标准不是越细越好，而是要能够确保代码清晰，便于交流的一个指导方针。</li></ol><p>XP方法最大价值在于项目中融会贯通地运用这12个最佳实践，而非单独使用。当然可以使用其中一些实践，单并不意味这就应用了XP方法。</p><h2 id="4-2-特征驱动开发方法"><a href="#4-2-特征驱动开发方法" class="headerlink" title="4.2 特征驱动开发方法"></a>4.2 特征驱动开发方法</h2><p>FDD也是一个迭代的开发模型。FDD每一步都强调质量，不断地交付可运行的软件，并以很小的开发提供准确的项目进度报告和状态信息。同敏捷开发一样，FDD弱化了过程在软件开发的地位。</p><h3 id="4-2-1-FDD的角色定义"><a href="#4-2-1-FDD的角色定义" class="headerlink" title="4.2.1 FDD的角色定义"></a>4.2.1 FDD的角色定义</h3><p>FDD认为，有效的软件开发不可或缺的三个要素是：人、过程和技术。软件开发不能没有过程，也不能没有技术，但最重要的还是人。定义了6中关键角色：</p><ol><li>项目经理。项目开发的组织者，是团队的保护屏障，提供一个适宜的开发环境。</li><li>首席架构设计师。负责系统的架构设计</li><li>开发经理。负责团队日常的开发工作的安排，解决开发过程中的技术问题和资源冲突</li><li>主程序员。主程序员将带领小组完成特征的详细设计和构件工作，一般要求主程序员具有一定的工作经验，并能够带动小组工作。</li><li>程序员。若干个程序员在主程序员带领下完成小组的开发，按照特征开发疾患完成开发</li><li>领域专家。领域专家是指对业务精通的人，一般有客户、系统分析师担当。</li></ol><h3 id="4-2-2-FDD的最佳实践"><a href="#4-2-2-FDD的最佳实践" class="headerlink" title="4.2.2 FDD的最佳实践"></a>4.2.2 FDD的最佳实践</h3><p>FDD最佳实践包括：领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管理、结果的可见性<br>其中最有特色的是个体所有，激活所有的而开发模型都是代码共有。但在FDD中，将类分配给特定的任何小组，分配给A小组的代码只能由A来维护，除A外的角色都不能修改它，只能使用它。<br>优点是：</p><ol><li>这个类的支配感会促使开发人员产生自豪感，从而更出色地完成任务。不过FDD也提到了类q</li><li>审查也是FDD中很具特设的一项实践。不少人认为审查是非常严格的软件过程特有的，然而FDD中明确将审查作为一项最佳实践。审查是一种很有效的发现缺陷的手段，但经常被忽视，国内的软件组织中很少有严格的审查制度保障软件质量。在开发阶段的代码审查机制能够很好的避免潜在的问题。</li></ol><p>缺点：</p><ol><li>项目依赖关系增强，形成代码黑盒，除了负责人没人能修改。</li></ol><h2 id="4-3-Scrum"><a href="#4-3-Scrum" class="headerlink" title="4.3 Scrum"></a>4.3 Scrum</h2><p>Scrum是一个用于开发和维护复杂产品框架，是一个增量的、迭代的开发过程。由若干个迭代周期组成，一个短的迭代周期成为Sprint,每个Sprint的建议周期在2到4周。在Scrum中，使用产品的Backlog来管理产品的需求，产品Backlog是一个按商业价值拍下的需求列表。<br>Scrum团队重产品的Backlog中挑选优先级最高的需求进行开发。<br>挑选的需求在sprint的计划会议上进行讨论、分析和估算得到相应的任务列表，称之为Sprint backlog.</p><h3 id="4-3-1-Scrum的5个活动"><a href="#4-3-1-Scrum的5个活动" class="headerlink" title="4.3.1 Scrum的5个活动"></a>4.3.1 Scrum的5个活动</h3><p><img src="leanote://file/getImage?fileId=5ea94009605ce63a32000000" alt></p><ol><li><p>产品待办事项的梳理——Prodct Backlog. 产品待办事项通常会很多，也很宽泛，而且想法会变来变去、优先级也会变化，所以产品待办事项列表的梳理是一个贯穿整个Scrum项目的活动。梳理包括：整理需求、优先级排序、事项分解、归并以及商业价值分析等。待办事项的梳理最好是所有团队成员参与，因为有可能需要其他技术或者团队的参与，而不是单单产品经理。</p></li><li><p>Sprint计划会议。每个Sprint工作周期以Sprint计划会议作为开始，让团队共同选择和理解即将到来的Sprint工作事项. Sprint计划会议的成功十分依赖产品待办事项列表的质量。Sprint计划会议工作内容有两部分：</p><ol><li>需要完成那些工作：产品负责人介绍排好序的代办事项，让整个Scrum团队共同理解这些工作。而产品待办事项的数目完全有开发团队决定，开发团队要考虑当天产品的增量状态，团队过去的工作情况，当前生产力等，产品负责人不能强加更多的工作量。</li><li>如何完成工作：开发团队根据当前的“完成的定义”一起决定如何实现一个产品增量，进行任务分解，前几天的工作分解成小单元，每个单元不超过一天，之后的任务可以稍微大一些，以后再对它进行分解。总之产品和开发团队一起考虑斌讨论产品待办事项，确保每个人对事项的理解一致，最终产出待办事项列表就是“Sprint 待办事项列表”，称之为Sprint Backlog</li></ol></li><li><p>每日Scrum会议。开发团队自组织，通过每日Scrum会议来确认他们任然可以实现Sprint的目标，每个人说下三点内容：上一个工作日完成了什么、当前工作日计划完成什么、有什么阻碍或风险。一般不超过15分钟。</p></li><li><p>Sprint评审会议。一个Sprint周期结束时，Scrum团队和相关人员一起评审Sprint的产出，Sprint评审会议向每个人展示当前的产品增量情况，帮助大家了解我们目前的进度到哪里，讨论他们在Sprint过程中看到了什么、有什么想法，并一起探讨下一步如何更好的推进。</p></li><li><p>Sprint回顾会议。每个Sprint周期结束之后，Scrum团队开回顾会议，目的是回顾一下团队在流程人际关系及工作方面做得如何，识别出团队中做得好的与不好的，并找潜在可以改进的事项，为将来的Sprint提供改进的计划</p></li></ol><h3 id="4-3-2-Scrum的5大价值观"><a href="#4-3-2-Scrum的5大价值观" class="headerlink" title="4.3.2 Scrum的5大价值观"></a>4.3.2 Scrum的5大价值观</h3><ol><li>承若——愿意对目标负责</li><li>专注——把你的心思和能力都用到你承诺的工作上去</li><li>开放——Scrum把项目中的一切开放给每个人看，做到信息透明</li><li>尊重——每个人都有他独特的背景和经验，尊重每个人的特点</li><li>勇气——有勇气做出承诺，履行程度，接受别人的尊重</li></ol><h2 id="4-4-水晶方法"><a href="#4-4-水晶方法" class="headerlink" title="4.4 水晶方法"></a>4.4 水晶方法</h2><p>水晶方法有七大体系特征：</p><ol><li>经常交付。没过一段时间或者几个月向用户交付可测试运行的代码，让用户有机会发现原来需求是否是他真正想要的，有机会将结果反馈到开发中。</li><li>反思改进。开发过程中难免会遇到一些技术难题、各种烦心事，会影响项目进度，所以我们应该经常在迭代中及时地进行反思和改进，从慌乱的日常开发中，抽一点时间来思考更为行之有效的方法。</li><li>渗透式交流。渗透式交流就是信息交流在团队成员中形成背景听觉，使得成员就像通过渗透一样获取相关信息。团队通过在一个共同的工作空间内，若其中一个成员提出问题，其他成员可以选择关注或不关注，也可以随时加入到讨论中来，选择性地获取相关交流的信息。</li><li>个人安全。当你勇敢指出了困扰你的问题时，你可以不用担心受到报复，应该有保护机制，鼓励大家发现和改正自身的缺点，而不是知而不言，这样就会对团队造成损害，不利于整个团队的协作和稳定。</li><li>焦点。也叫聚焦，明确知道要做什么，然后再安排时间，确保团队成员都清楚地了解他们自己最重要的任务是什么，确保他们能够充分利用时间去完成这些任务。</li><li>与专家用户简历方便的联系。与专家用户简历方便的联系能够给团队提供很好的帮助，例如对业务的专业理解，成品的质量和快速罚款，设计理念和需求背景，用户最新的需求等。</li><li>自动化测试。自动化测试是在开发在修改代码之后能够进行自动化测试，以便发现一些bug，让开发能够及时地进行修复，节省了整体的开发时间，提高效率。</li></ol><h2 id="4-5-其他敏捷方法——开放式源码"><a href="#4-5-其他敏捷方法——开放式源码" class="headerlink" title="4.5 其他敏捷方法——开放式源码"></a>4.5 其他敏捷方法——开放式源码</h2><p>开放式源码——是指以开放源码的方式运作，特别的就是开发人员可能地域分布很广，这和其他的敏捷方法不同，开放源码的一个好处就是排错的高度并行性，任何人都可以发现错误并修改代码提交给维护者。这里面体现的价值观就是猜测、合作和学习。</p><h1 id="5-软件重用"><a href="#5-软件重用" class="headerlink" title="5 软件重用"></a>5 软件重用</h1><p>软件产品和其他的产品不同，是抽象的，一旦产生就可以无限地复制，因此重复利用软件产品意义重大，可以节约大量的人力物力。软件重用包括：软件产品、源代码、文档、设计思想甚至领域知识。<br>常见的重用形式：</p><ol><li>源代码重用。这是简单最常见的重用形式，由于软件系统的复杂性，很难大规模地重用已有代码</li><li>架构重用。这个重用也很常见，随着软件架构风格和设计模式的推广和应用，架构重用已经对软件开发产生了重大影响</li><li>应用框架的重用。随着技术的发展，应用框架的重用变得越来越普遍，如AOP、EJB、Spring等应用框架技术</li><li>商业建模的重用。虽然软件领域各有不同，但是人们可以总结出常用的领域建模的方法，重用这些领域建模可以降低不确定性因素风险。</li><li>文档及过程的重用。有效地重用已有的文档有助于提高开发的效率</li><li>构件的重用。如第三方的组件，中间件等</li><li>软件服务的重用。随着web服务的提出，人们越来越关注服务的重用。例如SOA架构就是一个服务重用的实践，让一类功能收归到一个服务做不同业务软件的重用服务。</li></ol><h1 id="6-基于架构的软件设计"><a href="#6-基于架构的软件设计" class="headerlink" title="6 基于架构的软件设计"></a>6 基于架构的软件设计</h1><p>基于架构的软件设计（Architecture-Based Software Design,ABSD）是一种架构驱动的设计方法，这种方法有3个基础：</p><ol><li>功能分解。在功能分解中，ABSD方法使用已有的基于模块内聚和耦合技术</li><li>通过选择架构风格来实现质量和业务需求</li><li>软件模板的使用。软件模板利用了一些软件系统的结构。</li></ol><p>ABSB模型是吧整个过程划分为：架构需求、设计、文档化、复审、实现和演化</p><h2 id="6-1-ABSB方法与生命周期"><a href="#6-1-ABSB方法与生命周期" class="headerlink" title="6.1 ABSB方法与生命周期"></a>6.1 ABSB方法与生命周期</h2><p><img src="leanote://file/getImage?fileId=5ea97d8a605ce63a32000001" alt></p><h2 id="6-2-基于架构的软件开发模型"><a href="#6-2-基于架构的软件开发模型" class="headerlink" title="6.2 基于架构的软件开发模型"></a>6.2 基于架构的软件开发模型</h2><p>基于架构的软件开发模型（Architecture-Based Software Design Model，ABSDM）把整个基于架构的软件过程划分为架构需求、架构设计、架构文档化、架构复审、架构实现和架构演化6个子过程：<br><img src="leanote://file/getImage?fileId=5eaa3c4f605ce63a32000002" alt></p><ol><li>机构需求。是指用户对目标软件在系统功能、行为、性能、设计约束方面的期望。通过用户的需求，架构师根据技术环境和架构师经验标注出所需要的构件，最后进行需求的评审。必要时“需求获取——标识构件——需求评审”之间进行迭代。</li><li>架构设计。根据架构需求提出架构的模型、映射构件、分析构件相互作用、产生架构、设计评审</li><li>架构文档化。绝大多数架构都是抽象的，有一些概念的构件组成。为了开发人员更好地理解和实现架构，必须把架构进行文档化描述</li><li>架构复审。架构设计完成之后要安排一次由外部人员（用户和领域专家）参与的复审，其目的是识别潜在的风险，及早发现架构设计中的缺陷和错误，包括架构能否满足需求、质量需求是否得到体现、是否清晰、构件是否划分合理、文档标识是否明确、以及构架设计是否满足功能和性能要求等等</li><li>架构实现。开发人员根据复审后的架构文档，分析和实现其中的构件，然后组装测试的一个过程。</li><li>架构演化。在架构开发中，用户的需求可能变动，在开发完成正常运行后，也可能发生需求变化。那么就要相应地调整架构以适应新的软件需求。主要过程包括这7个步骤：需求变动归类、架构演化计划、构件变动、更新构件的相互作用关系、构件组装和测试、技术评审、技术评审，最后得出演化后的架构设计。</li></ol><h1 id="7-形式化方法"><a href="#7-形式化方法" class="headerlink" title="7 形式化方法"></a>7 形式化方法</h1><p>形式化方法是指采用严格的数据方法对软件的描述、开发和验证的过程进行严格规约的一种方法，通过这种方式可以需求和定义人员与开发人员的理解偏差，避免模糊性和二义性。通过形式化描述进行需求分析的质量大大提高，很多自然语言描述无法避免的缺陷在需求分析阶段就会被发现并等到解决，从而降低了后期的开发和维护的成本。形式化描述可以通过计算计算进行自动处理（一些专业软件），进行一致性检查和证明。<br>一般一些安全要求较高的，如地铁、高铁、航空、核电等软件会考虑使用这种开发方法来保证系统的安全和可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态壁纸接口</title>
      <link href="/2019-11-28-dong-tai-bi-zhi-jie-kou/"/>
      <url>/2019-11-28-dong-tai-bi-zhi-jie-kou/</url>
      
        <content type="html"><![CDATA[<h1 id="新浪动态壁纸接口"><a href="#新浪动态壁纸接口" class="headerlink" title="新浪动态壁纸接口"></a>新浪动态壁纸接口</h1><p>说明：<a href="https://www.nulltm.com/tag/随机" target="_blank" rel="noopener">随机</a>图片<a href="https://www.nulltm.com/tag/壁纸" target="_blank" rel="noopener">壁纸</a><a href="https://www.nulltm.com/tag/api" target="_blank" rel="noopener">api</a>，调用的是<a href="https://www.nulltm.com/tag/新浪" target="_blank" rel="noopener">新浪</a>api，速度不用担心，图片资源也很多</p><p>电脑动漫图片：<a href="https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=dongman" target="_blank" rel="noopener">http://api.btstu.cn/sjbz/?lx=dongman</a></p><p>电脑美女图片：<a href="https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=meizi" target="_blank" rel="noopener">http://api.btstu.cn/sjbz/?lx=meizi</a></p><p>电脑随机动漫妹子：<a href="https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=suiji" target="_blank" rel="noopener">http://api.btstu.cn/sjbz/?lx=suiji</a></p><p>手机动漫图片：<a href="https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=m_dongman" target="_blank" rel="noopener">http://api.btstu.cn/sjbz/?lx=m_dongman</a></p><p>手机美女图片：<a href="https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=m_meizi" target="_blank" rel="noopener">http://api.btstu.cn/sjbz/?lx=m_meizi</a></p><p>手机随机动漫妹子：<a href="https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?m_lx=suiji" target="_blank" rel="noopener">http://api.btstu.cn/sjbz/?m_lx=suiji</a></p><p>手机电脑自动判断，电脑显示适合电脑的壁纸，手机显示适合手机的壁纸 <a href="https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/zsy.php" target="_blank" rel="noopener">http://api.btstu.cn/sjbz/zsy.php</a></p><p>api现在已经有几千张图了，每天都在增加，大家可以玩玩</p><h1 id="必应动态壁纸接口"><a href="#必应动态壁纸接口" class="headerlink" title="必应动态壁纸接口"></a>必应动态壁纸接口</h1><p>必应在国内的名气不是很大，很多人不知道。必应是美国微软的搜索引擎，类似与百度。不过，有个地方很有趣，必应的首页背景图，每日一换，从不重复。都是团队精选的世界各地的风景、人文类的美图，配有相关文字描述。还是挺有意思的，不过好像只能保存近10多日的数据，超期就无法访问了。</p><p>首先，第一个接口：<a href="http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1" target="_blank" rel="noopener">http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a></p><p>可以获得当日的必应壁纸无水印高清图片的路径以及版权等信息。具体返回格式如下：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"images"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>        <span class="token property">"startdate"</span><span class="token operator">:</span> <span class="token string">"20181118"</span><span class="token punctuation">,</span>        <span class="token property">"fullstartdate"</span><span class="token operator">:</span> <span class="token string">"201811181600"</span><span class="token punctuation">,</span>        <span class="token property">"enddate"</span><span class="token operator">:</span> <span class="token string">"20181119"</span><span class="token punctuation">,</span>        <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838_1920x1080.jpg"</span><span class="token punctuation">,</span>        <span class="token property">"urlbase"</span><span class="token operator">:</span> <span class="token string">"/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838"</span><span class="token punctuation">,</span>        <span class="token property">"copyright"</span><span class="token operator">:</span> <span class="token string">"锡安国家公园内的维尔京河，美国犹他州 (© Justinreznick/Getty Images)"</span><span class="token punctuation">,</span>        <span class="token property">"copyrightlink"</span><span class="token operator">:</span> <span class="token string">"http://www.bing.com/search?q=%E9%94%A1%E5%AE%89%E5%9B%BD%E5%AE%B6%E5%85%AC%E5%9B%AD&amp;form=hpcapt&amp;mkt=zh-cn"</span><span class="token punctuation">,</span>        <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        <span class="token property">"quiz"</span><span class="token operator">:</span> <span class="token string">"/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20181118_NarrowsZion%22&amp;FORM=HPQUIZ"</span><span class="token punctuation">,</span>        <span class="token property">"wp"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token property">"hsh"</span><span class="token operator">:</span> <span class="token string">"a2d2b96a5c113e78bc7a0f8a508cbf73"</span><span class="token punctuation">,</span>        <span class="token property">"drk"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"top"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"bot"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"hs"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"tooltips"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"loading"</span><span class="token operator">:</span> <span class="token string">"正在加载..."</span><span class="token punctuation">,</span>        <span class="token property">"previous"</span><span class="token operator">:</span> <span class="token string">"上一个图像"</span><span class="token punctuation">,</span>        <span class="token property">"next"</span><span class="token operator">:</span> <span class="token string">"下一个图像"</span><span class="token punctuation">,</span>        <span class="token property">"walle"</span><span class="token operator">:</span> <span class="token string">"此图片不能下载用作壁纸。"</span><span class="token punctuation">,</span>        <span class="token property">"walls"</span><span class="token operator">:</span> <span class="token string">"下载今日美图。仅限用作桌面壁纸。"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在url的路径上，拼上域名即可拿到图片：</p><p><a href="https://cn.bing.com/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838_1920x1080.jpg（如果这个打不开，请认真重读第一段最后几句。）" target="_blank" rel="noopener">https://cn.bing.com/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838_1920x1080.jpg（如果这个打不开，请认真重读第一段最后几句。）</a></p><p>值得注意的是，接口里的idx=后面的数字为0是今日的壁纸数据，1 2  3  4  5…依次是昨日、前日…   数字是-1是明日的数据。</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"date"</span><span class="token operator">:</span> <span class="token string">"November 19"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"峡谷秘境"</span><span class="token punctuation">,</span>    <span class="token property">"attribute"</span><span class="token operator">:</span> <span class="token string">"美国，锡安国家公园"</span><span class="token punctuation">,</span>    <span class="token property">"para1"</span><span class="token operator">:</span> <span class="token string">"今天是美国犹他州锡安国家公园成立99周年的日子，一直以来，它是美国访问量最大的国家公园之一。这里到处都是令人惊叹的西南风景，包括锡安峡谷。壁纸中的地方叫做纳罗斯水道，它是一条穿过峡谷十分狭窄的小径，有的地方甚至只能勉强过一个人，而且有时需要淌着水行走。虽然这个时候水有点冷，但是这里的景色，一个转弯一个惊喜。"</span><span class="token punctuation">,</span>    <span class="token property">"para2"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>    <span class="token property">"provider"</span><span class="token operator">:</span> <span class="token string">"© Justinreznick/Getty Images"</span><span class="token punctuation">,</span>    <span class="token property">"imageUrl"</span><span class="token operator">:</span> <span class="token string">"http://hpimges.blob.core.chinacloudapi.cn/coverstory/watermark_narrowszion_zh-cn9686302838_1920x1080.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"primaryImageUrl"</span><span class="token operator">:</span> <span class="token string">"http://hpimges.blob.core.chinacloudapi.cn/coverstory/watermark_narrowszion_zh-cn9686302838_1920x1080.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"Country"</span><span class="token operator">:</span> <span class="token string">"美国"</span><span class="token punctuation">,</span>    <span class="token property">"City"</span><span class="token operator">:</span> <span class="token string">"锡安国家公园"</span><span class="token punctuation">,</span>    <span class="token property">"Longitude"</span><span class="token operator">:</span> <span class="token string">"-112.946625"</span><span class="token punctuation">,</span>    <span class="token property">"Latitude"</span><span class="token operator">:</span> <span class="token string">"37.306900"</span><span class="token punctuation">,</span>    <span class="token property">"Continent"</span><span class="token operator">:</span> <span class="token string">"北美洲"</span><span class="token punctuation">,</span>    <span class="token property">"CityInEnglish"</span><span class="token operator">:</span> <span class="token string">"Zion National Park"</span><span class="token punctuation">,</span>    <span class="token property">"CountryCode"</span><span class="token operator">:</span> <span class="token string">"US"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在后面加?d=20181111则是提取2018年11月11日的壁纸故事。这个时间可以从20140501-至今.</p><p><a href="https://cn.bing.com/cnhp/coverstory?d=20181118" target="_blank" rel="noopener">https://cn.bing.com/cnhp/coverstory?d=20181118</a></p><p>有了这些，你就可以搭建一个壁纸站了，每日抓取官方壁纸数据展示，个人觉得，把这些保存下来还是挺有意义的。我前几日借用这两个接口写了一个简单的壁纸站，如果你实在懒得去弄的话，可以随时访问下载哦！最后留个链接，点击这里吧！必应壁纸</p><p>附：</p><p>如果你的网站想要每天更换壁纸壁纸，又不想写接口。下面这几个我写的接口就适合你了！</p><p><a href="https://api.neweb.top/bing.php" target="_blank" rel="noopener">https://api.neweb.top/bing.php</a>   —–必应当日壁纸</p><p><a href="https://api.neweb.top/bing.php?type=future" target="_blank" rel="noopener">https://api.neweb.top/bing.php?type=future</a>   ——必应明日壁纸</p><p><a href="https://api.neweb.top/bing.php?type=rand" target="_blank" rel="noopener">https://api.neweb.top/bing.php?type=rand</a>   —–近7日随机壁纸</p><p>图片demo：（分别是明天、今天、随机的必应壁纸）</p><p>使用方法：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://api.neweb.top/bing.php<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>必应壁纸<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链技术之比特币运作原理</title>
      <link href="/qu-kuai-lian-ji-zhu-zhi-bi-te-bi-yun-zuo-yuan-li/"/>
      <url>/qu-kuai-lian-ji-zhu-zhi-bi-te-bi-yun-zuo-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是比特币"><a href="#什么是比特币" class="headerlink" title="什么是比特币"></a>什么是比特币</h1><p>点对点的传输的一个去中心化的电子现金系统。每个节点都共同维护一个区块链形式存储的交易记录，每个比特币节点遵守同一个比特币网络协议，并基于密码学原理加密每一笔交易记录和区块，实现每一笔交易不可逆、防篡改、去中心化的、数据可监管溯源的电子现金交易系统。</p><h2 id="比特币特点"><a href="#比特币特点" class="headerlink" title="比特币特点"></a>比特币特点</h2><ul><li>比特币最初由中本聪2008年发明</li><li>比特币发行和交易不依赖中央机构</li><li>比特币的发行总量不会超过2100万个</li><li>只要能够联网，安装比特币客户端，任何人都能接入到这个比特币网络</li><li>比特币的账户地址是匿名的</li><li>任何国家或者机构无法监管或者操纵这个比特币网络</li><li>比特币是基于现代密码学实现的点对点交易的分布式超级账本</li></ul><h1 id="比特币行情"><a href="#比特币行情" class="headerlink" title="比特币行情"></a>比特币行情</h1><p>比特币从诞生以来已经翻了好几万倍了，比特币的第一笔交易是一个程序员用50btc买了披萨，第一批持有比特币的人估计早已经是千万富翁，但是神奇的比特币之父中本聪的创始区块及它的账户的其他比特币都还没有发生转账交易。<br><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508680.png" alt></p><h1 id="区中心化的比特币网络"><a href="#区中心化的比特币网络" class="headerlink" title="区中心化的比特币网络"></a>区中心化的比特币网络</h1><p><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage.png" alt></p><p>这个比特币网络大致是这个样子的，节点分为以下几类：</p><ul><li>全数据节点：保存了完整的区块链所有交易信息</li><li>矿工节点：负责打包新的交易数据制作新的区块</li><li>轻客户端节钱包节点：只保留自己关心交易数据</li></ul><h1 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h1><p><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508350.png" alt><br>区块链有以下几个特点：</p><ul><li>区块链本质是一个分布式的超级账本，整个比特币网络各个节点仅仅认可和维护记录一样且长度最长的区块链</li><li>每个区块由区块头（上一个区块的hash值，当前区块的高度，出块的时间等）+ 交易记录列表 组成</li><li>所有经过验证符合比特币协议的交易记录都会被“矿工”打包进新的区块，然后广播给所有其它节点。</li></ul><p>每一个新的区块的都有一个指向上一个区块的hash值，所以这条链被形象的称之为<strong>区块链</strong></p><h1 id="什么是挖矿"><a href="#什么是挖矿" class="headerlink" title="什么是挖矿"></a>什么是挖矿</h1><p><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508575.png" alt><br>上图是传统的煤矿挖矿的矿工，比特币的“挖矿”当然不是这个挖矿。<br>比特币的挖矿是指：将接收到全网的交易记录打包制作到一个新区块并广播至其它节点的过程，由于这个过程通常不是那么容易，需要不停的hash计算符合标准的随机数才能生效新区块，平均全网每10分钟才能有计算出这样的随机数，所以形象的形容为比特币的“挖矿”</p><h2 id="挖矿的原理"><a href="#挖矿的原理" class="headerlink" title="挖矿的原理"></a>挖矿的原理</h2><p><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508972.png" alt><br>挖矿的过程如下：</p><ol><li>每个矿工节点都共同监听最新的交易数据，并做合法性校验，将符合校验的交易打包进新的区块中</li><li>在新的区块中添加给矿工账户转账的一笔交易，给矿工自己加上相应的比特币奖励和交易记录收取的手续费</li><li>最后一步用新区块的所有内容+一个随机数做SHA-256计算出hash值，使得这个hash值的二进制数符合一定规则，才能向全网广播这个新的区块</li></ol><p>那么接下来我们思考下以下三个问题：</p><ol><li>整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？</li><li>这种“苦力活”如果没人做怎么办？</li><li>如果这个矿工“不老实”怎么办？</li></ol><h3 id="1-整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？"><a href="#1-整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？" class="headerlink" title="1. 整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？"></a>1. 整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？</h3><p><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508157.png" alt><br>在比特币的协议中规定，给挖矿过程增加了一定的难度，使得矿工挖矿并不是那么容易，一般是全网的所有矿工节点的所有算力一起计算10分钟才能制作出一个合法的新区块。<br>有了这个规定，这个比特币网络就有充足的时间让大部分节点同步最新的区块数据，而减少并发问题。这个挖矿的难度在比特币中就叫工作量证明机制（Proof-of-Work，PoW）。</p><p>刚刚提到的10分钟，为什么是10分钟，是怎么保证的？</p><p>先来回答下为什么是10分钟，而不是15分钟、2分钟、8分钟，中本聪在设计比特币机制时，考虑到新区块数据在全世界节点的广播同步有一定的网络延迟，于是为了尽量避免“矿工A和矿工B在不知道对方都计算出结果的情况下同时发送计算结果”的事情，规定了制作新区款的难度，这个难度难到平均每个矿工需要花10分钟挖出一个区块，于是设计了一个这样的值：理论平均出块时间=10分钟。至于为什么是10分钟，那总得取一个值吧，综合考量就定了10分钟。</p><p>是怎么保证全网的平均出块时间一直保证在10分钟，不会随着计算能力的提升，就不需要10分钟了吗？</p><p>比特币规定，每挖完2016个区块，数学题的难度会自动的根据这2016个区块的实际挖出时间，动态地做出调整。</p><p>也就是说，每2016个区块的难度都是一样的，接下来的2016个区块的难度，根据前2016个区块的难度以及前2016个区块的整体实际挖矿时间综合决定，这里有个计算公式如下：<br><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508078.png" alt><br>可以看出10分钟不是绝对值，有的矿工可能运气好一些、3分钟、5分钟就能找到符合标准的新区块，有的矿工运气差一些，可能需要20分钟、30分钟才能找到符合标准的新区块，由于有了这个标准的动态调整，总能保证全网的平均出块时间在10分钟左右。<br>具体这个难度是什么，我们看下面公式：<br><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508135.png" alt><br>而上面的这个目标值b就是和挖矿难度系数有关的值，目前的难度就是SHA-256【制作新区款的所有内容+一个随机数】的hash值的二进制值至少前72位为零，也就是最坏的结果是至少需要计算2^72次才能找到这个随机数，你可以认为这个72就是一个难度系数值</p><p>有了这个工作量证明机制就能保证一定全网在同一时刻只有一个矿工制作成符合标准的新区块吗，答案是否定的，那么如果出现这个情况，比特币网络是怎么处理的？</p><p>E矿工和F矿工分别基于d区块制作出了新的区块并广播至其他节点，如下图：<br><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508546.png" alt></p><p>同时收到e区块和f区块的节点会先同时保留这些区块，直到下一个区块基于其中一个区块制作出更长的区块链</p><p><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508291.png" alt></p><p>比特币协议规定只保留最长的区块链，较短的支链中的交易记录重新变为待确认交易重新发送至矿工节点作确认</p><p><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508312.png" alt></p><p>如果下一个区块碰巧又分别有两个新的区块基于e区块和f区块制作新区块，比特币网络的做法和上面的是一样的，先同时保留这些支链，直到最长的区块链出现，较短的区块的交易记录变为待确认交易重新发送至别人矿工节点。</p><h3 id="2-这种“苦力活”如果没人做怎么办？"><a href="#2-这种“苦力活”如果没人做怎么办？" class="headerlink" title="2. 这种“苦力活”如果没人做怎么办？"></a>2. 这种“苦力活”如果没人做怎么办？</h3><p>比特币网络规定每成功生成一个新的区块，给相应的BTC给矿工账号作为奖励，并将新区块中的交易的手续费也归矿工所有，通过这个奖励机制大家就很乐意去干这个“苦力活”了。</p><p>这个奖励最初是50比特币，今后每产生21万个区块，比特币数量都会依次减半。直到第33次减半时，每个块产生0.0021个新比特币直接减为0个，最终比特币总量维持在2100万个。我们知道比特币大约每10分钟产生一个区块，而21万个10分钟接近4年。<br>最终这个比特币网络的矿工只能通过收取交易的手续费来维持他们的成本和收益<br>这个交易的手续费是可以交易方自己定的<br>但是矿工有权利优先选择手续费较高的记账或者拒绝，只要矿工们达成共识。</p><h2 id="挖矿工具——矿机"><a href="#挖矿工具——矿机" class="headerlink" title="挖矿工具——矿机"></a>挖矿工具——矿机</h2><p>挖矿的矿机从最初的使用PC个人电脑挖矿到专业的挖矿矿池，算力变得越来越强，挖矿的成本也越来越高，门槛越来越高。<br><strong>CPU挖矿→GPU挖矿→专业矿机挖矿→矿池挖矿</strong><br><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508408.png" alt><br><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508413.png" alt><br><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508512.png" alt><br><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508831.png" alt></p><h1 id="比特币是如何进行交易的"><a href="#比特币是如何进行交易的" class="headerlink" title="比特币是如何进行交易的"></a>比特币是如何进行交易的</h1><p>比特币交易符合以下几个特点：</p><ul><li>交易数据包含交易输入和交易输出，其中交易输入的金额总和必须&gt;=输出金额总和</li><li>挖矿奖励属于一个特殊的交易（称为coinbase交易），可以没有输入。</li><li>在比特币没有余额概念，只有分散到区块链里的UTXO（未花费交易记录）</li><li>UTXO是交易的基本单元，不能在分割。</li></ul><h2 id="比特币转账"><a href="#比特币转账" class="headerlink" title="比特币转账"></a>比特币转账</h2><p>比特币的交易记录主要由以下几部分组成：</p><ul><li>交易的输入，是指向上一笔交易的hash值</li><li>交易的输入解锁脚本，能够证明这笔钱你有权动用</li><li>交易的输出，交易的输出对方账户</li><li>交易输出的加锁脚本，是的对方必须提供证明是转给他的，才有权动用</li></ul><p><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508663.png" alt><br>上表格中：<br>记录1是个特殊的交易记录，是比特币矿工的奖励记录，给A账户转账10BTC，所以没有交易输入，这个交易记录叫coinbase<br>记录2:A使用记录1转给他的钱用来支付给B,并加锁这个转账<br>记录3：B收到这个转账时，提供自己的签名和公钥，证明确实是转给他的，B再用这笔转账支付10BTC给C</p><p>从上面的交易得知，<strong>我们把以上交易记录中可以用来当下一笔交易的未使用记录，称之为未花费记录（UTXO）</strong></p><p>我们再来看下面这个记录：<br><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120509067.png" alt></p><p>记录2中A需要支付5BTC给B，但是交易输入记录1是10BTC的，所以将自己的账户添加到交易输出中找回5BTC</p><p>记录4由于A需要支付10BTC，所以交易输入是两笔5BTC的交易记录。</p><p>从上面的交易可以看出,<strong>比特币系统中没有账户的概念，只有交易记录，一笔未花费交易记录不能拆开使用，如果要只需花费一部分，通过在交易输出添加一笔给自己转账的记录，类似现金找零。</strong></p><h3 id="如何防止同一笔前用两次"><a href="#如何防止同一笔前用两次" class="headerlink" title="如何防止同一笔前用两次"></a>如何防止同一笔前用两次</h3><p>A账号用【记录1】当做输入支付给10BTC给“B账号”，接着又用【记录1】当做输入支付给10BTC给“C账号”,<br>相当于10BTC用了两次。如下图：<br><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508784.png" alt></p><p>我们分情况来看同一笔交易输入支付给了不同的人：<br><strong>情况1：</strong>两条交易记录打包在同一个区块中：那么以先收到的交易是合法的，后收到的交易是非法的<br><strong>情况2：</strong>两条交易记录先后被打包进不同区块的同一主链中：那么当矿工验证交易合法性时，是从以往合法的所有区块的所有交易中查找验证的，先收到的交易是合法的，后收到的是非法的<br><strong>情况2：</strong>两条交易记录先后被打包进不同区块的不同支链中：<br>A矿工在之前主链基础上制作新区款，先收到交易1；<br>B矿工在之前主链基础上制作新区款，先收到交易2。<br>那么矿工在做合法性验证时都认为是合法的，此时比特币网络发生分叉，随着之后新区款制作，根据比特币协议规定，将保留区块长度最长的链，较短的支链将丢弃，其中的交易记录重新变为未确认交易等待下一个新区块的合法性校验，此时校验不通过的交易将丢弃。</p><h2 id="真实的比特币交易数据的结构"><a href="#真实的比特币交易数据的结构" class="headerlink" title="真实的比特币交易数据的结构"></a>真实的比特币交易数据的结构</h2><pre><code>{   &quot;lock_time&quot;:0,   &quot;size&quot;:259,   &quot;version&quot;:1,   &quot;vin_sz&quot;:1,   “hash”:“2514161c059ac18bf2eff1e05c4628e322d846e930fd6dd4b24805ea59dc4913”,//这笔交易的ID   &quot;vout_sz&quot;:2,   “inputs”:[//这笔交易的的来源交易，也称输入交易，可能有多个      {         &quot;prev_out&quot;:{        “hash”:“4f40655c4ab1a029bc41bc547f79556a0dc48d22df7202778fad592791c77fcd”,//上一笔交易的交易ID        “index”:0 //在上一笔交易的输出列表的下标位置         },         “script”:“493046022100cd6795ebcd1b6b87833a4ad812733d3804065d34bafee24da181a770892272b902210088cd2484952ad2572f9bfb2874643dbb4b3c492b749e79d8177a14eb4a3bc61a014104bbf2b84900b6f898548687aefba86cc06da6f4656a71e45fa55128b501455b5486cb09705cfa23c1899fe46d4355c9058bb2de4f1a7f1a01ff27e00b306f7356” //解锁上一笔交易输出的参数      }   ],    “out”:[//这笔交易的交易对手方，也称交易输出，也可以有多个      {       //交易输出的锁定脚本，只有交易对方提供正确的自己的签名及公钥才能证明这笔钱是转给他的，才有资格进行下一次的转账交易         “script_string”:“OP_DUP OP_HASH160 f9d49c5cf3e120ad1be60b67d868603a8fc945d2 OP_EQUALVERIFY OP_CHECKSIG”,         &quot;address&quot;:&quot;1PmyxDv5VvGoSAKMr1DQcWB6sHPx1ZbgWe&quot;,         “value”:88994500000,//转多少钱，单位是聪，1亿聪=1BTC         &quot;script&quot;:&quot;76a914f9d49c5cf3e120ad1be60b67d868603a8fc945d288ac&quot;      },      {         &quot;script_string&quot;:&quot;OP_DUP OP_HASH160 088465c1f0c8b3b3da06f7073a921d6b95b22f49 OP_EQUALVERIFY OP_CHECKSIG&quot;,         &quot;address&quot;:&quot;1n31g4rKiEeXnZEZR6VZwm3LggLicEqEC&quot;,         &quot;value&quot;:1000000000,         &quot;script&quot;:&quot;76a914088465c1f0c8b3b3da06f7073a921d6b95b22f4988ac&quot;      }   ]}</code></pre><h2 id="比特币的脚本语言"><a href="#比特币的脚本语言" class="headerlink" title="比特币的脚本语言"></a>比特币的脚本语言</h2><pre><code>OP_DUP OP_HASH160 f9d49c5cf3e120ad1be60b67d868603a8fc945d2 OP_EQUALVERIFY OP_CHECKSIG</code></pre><p>上面是比特币交易中的交易输入解锁脚本，输入两个参数：<sig> <pubk> 使得<pubk>的HASH160值等于9d49c5cf3e120ad1be60b67d868603a8fc945d2，接着使用<pubk>验证<sig>签名，验证同步则表示该交易输入合法有效，就像用户名密码一样。</sig></pubk></pubk></pubk></sig></p><p>比特币脚本语言是非图灵完备脚本语言，就是说它不能实现复杂的逻辑。<br>比特币脚本语言的执行是遵循先进后出的原因，即它的变量读取是堆栈式，如下图：</p><p><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120509028.png" alt><br><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508906.png" alt></p><h2 id="最终的结构"><a href="#最终的结构" class="headerlink" title="最终的结构"></a>最终的结构</h2><p>比特币就是通过每一个区块都有上一个区块的指正，每个区块中包含通过验证的合法交易组成的链式结构，并让所有节点同步这份数据，形成不可逆，串改成本巨大的分布式超级账本，称之为区块链<br><img src="../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120509220.png" alt></p><h1 id="比特币的价值及存在问题"><a href="#比特币的价值及存在问题" class="headerlink" title="比特币的价值及存在问题"></a>比特币的价值及存在问题</h1><p>比特币的价值在于，金融危机发生的时候，货币超发，法币贬值，社会财富缩水；<br>而比特币不依赖中央机构管理，期价值完全由供给关系决定，<br>当旧的法定货币崩溃时，人们便会涌向比特币，把比特币作为新的资产避风港——“21世纪版的黄金”<br>比特币是目前区块链技术落地最成功的项目，虽然比特币目前实际用的更多的是黑产（赌博、洗钱、黑客敲诈、传销），但是开创了人们对区块链技术无限探索和想象；</p><p>但同样存在着问题：</p><ul><li>由于有新区块难度限制，每秒处理交易数不足7/sec，交易确认时间长大几小时甚至几天交易确认时间长大几小时甚至几天</li><li>巨大的能源消耗（这也是比特币防篡改的代价）</li><li>随着计算机算力的提升，构建数字货币的密码学可能会被攻破</li><li>投机性强，泡沫大</li><li>算力集中，随着挖矿难度增加，只有少数几个矿池能够维持挖矿成本，失去去中心化初衷</li></ul><h1 id="区块链的应用"><a href="#区块链的应用" class="headerlink" title="区块链的应用"></a>区块链的应用</h1><p>基于区块链的记录不可逆、去中心化、全民监管的特点来构建一个信任网络，降低<br>社会协同合作成本，主要应用如下：</p><ul><li>企业融资：企业可以通过发行代币的方式对投资者承诺未来能够通过代币购买</li><li>公共实物：居于区块链上的登记的信息不可篡改，能够很方便的证明你的信息合法性</li><li>公益：在当前大环境下，听到慈善、公益，心里就不是滋味——信息不透明、 监督困难；利用区块链技术能够追踪每一笔善款的去向</li><li>供应链：结合物联网实现对物品信息的区块链管理，做到每个每个商品从生产到消费者的每一个环节，做到正品溯源；</li><li>供应链金融：代理商可以低成本的通过货物抵押向供应商赊账，并利用区块链智能合约技术保证物品出售时自动回款给供应商</li><li>物流：通过区块链技术做到CP间的信息信任，较少物流环节的信息交换成本，并通过区块链加密技术做到信息的保护。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>区块链为信息时代的去中心化信息交易提供了良好的解决思路</li><li>区块链只是一种解决问题的技术，一定是结合实际场景落地才能有好的未来，否则就是技术人和投机者的一场狂欢。</li><li>炒币有风险，入市需谨慎</li></ul><h1 id="了解区块链的一些网站："><a href="#了解区块链的一些网站：" class="headerlink" title="了解区块链的一些网站："></a>了解区块链的一些网站：</h1><p>区块链相关导航：<a href="https://www.feixiaohao.com/daohanglist/" target="_blank" rel="noopener">https://www.feixiaohao.com/daohanglist/</a><br>比特币富豪排行榜：<a href="http://bitop.top/" target="_blank" rel="noopener">http://bitop.top/</a><a href="http://bitop.top/" target="_blank" rel="noopener">http://bitop.top/</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RokectMQ 和Kafka对比</title>
      <link href="/rocketmq-vs-kafka/"/>
      <url>/rocketmq-vs-kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="RokectMQ-和Kafka对比"><a href="#RokectMQ-和Kafka对比" class="headerlink" title="RokectMQ 和Kafka对比"></a>RokectMQ 和Kafka对比</h1><table><thead><tr><th>对比项</th><th>Kafka</th><th>RocketMQ</th><th>总结</th></tr></thead><tbody><tr><td>部署架构</td><td><img src="../images/rocketmq-vs-kafka/1562836313289_5.png" alt="img"></td><td><img src="../images/rocketmq-vs-kafka/1562836232412_3.webp" alt="img"></td><td>1. Zookeeper对应NameServer,NameServer没有用强一直的watch来监听各个节点可靠性，而是使用心跳机制。<br>2. RocketMQ没有用ZK做高可用负载，原因是Broker在RocketMQ中就是物理概念，一台机器就是一个broker,Broker-Master和Broker-Slave关系在部署初始化是确认，运行过程中无需负载的选主切换，当然RMQ也就不支持在Broker-Master挂掉是自主选主Slave为master,需要手动切换。</td></tr><tr><td>行3架构拓扑图</td><td><img src="../images/rocketmq-vs-kafka/1562837115046_7-1574933554003.png" alt="img"></td><td><img src="../images/rocketmq-vs-kafka/1562837123812_9.png" alt="img"></td><td>1.kafka的partition对应rmq的queue<br>2.都可以为topic指定对应的分区数量<br>3.通过topic创建命令来说明topic、partition和broker<br>(Master/Slave)的关系<br>kafka:<br> <em>sh bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 3 –partitions 3 –topic mytopic</em> <br>roketmq:<br> <em>sh /root/rocketmq/bin/mqadmin updateTopic -c defaultCluster -readQueueNums/writeQueueNums 3 -t mytopic</em> <br>可以看出不一样的是kafka需要指定<br>–replication-factor来说明这个topic一个master需要几个slave，而rmq不需要，因为这个Master/slave拓扑结构是在配置写死的<br>4. Kafka的Master/slave是逻辑结构，可以是同一台机器，而rmq不行，必须在初始化时就在配置文件中写死，要么是不同机器，要么是同一机器的不同进程（可以是端口不一样），是对应的物理结构。kafka可实现在通过zk自动Slave升级成Master<br>5. Rmq之所以没有用zk做主备自动切换，也是为了简化整个系统的复杂度，无需过多的关心选主和一致性的问题，同时也为了保证消息的不乱序消费，造成业务异常。</td></tr><tr><td>消息存储</td><td><img src="../images/rocketmq-vs-kafka/1562838493614_11.jpeg" alt="img"></td><td><img src="../images/rocketmq-vs-kafka/1562838500422_13.jpeg" alt="img"></td><td>1.kafka和rmq都是用文件形式来持久化消息2. kafka为每个partiion单独文件存储；而rmq不是所有的topic的所有queue的数据存储在commitlog中（默认按1G大小存储，超过时新建一个文件，按文件大小偏移量命名），并每个topic的每个queue用consumerqueue小文件存储消费位点信息，可以通过消费位点到commitlog快速定位到对应的数据行。rocketmq这样做的好处是：文件顺序写，小文件随机读。优化了kafka当topic较多时的性能问题。那么rmq是怎么做到的：<br> - producer消息先投递到commitlog,异步最终一致写入consumerqueue - 由于是一个文件，根据linux文件写入缓存页批量写的机制，写入非常迅速，因为没有多个文件的资源竞争<br>- 随机读，因为cosumerqueue中的数据非常少，能够一次性读取很多数据，访问速度和内存相当，通过预读取机制这部分性能可以忽略不计，对于commitlog这个大文件虽然是随机读，但是整体是有序的，还是可以充分利用PageCache的性能，再加上文件内存映射技术，很好的保障了在很多topic下的读写性能。</td></tr><tr><td>性能</td><td>单机写入TPS约在百万条/秒，消息大小10个字节</td><td>RocketMQ单机写入TPS单实例约7万条/秒，单机部署3个Broker，可以跑到最高12万条/秒，消息大小10个字节</td><td>1. Kafka的TPS跑到单机百万，主要是由于Producer端将多个小消息合并，批量发向Broker <br> 2. RocketMQ为什么没有这么做？Producer通常使用Java语言，缓存过多消息，GC是个很严重的问题Producer调用发送消息接口，消息未发送到Broker，向业务返回成功，此时Producer宕机，会导致消息丢失，业务出错Producer通常为分布式系统，且每台机器都是多线程发送，我们认为线上的系统单个Producer每秒产生的数据量有限，不可能上万。缓存的功能完全可以由上层业务完成。</td></tr><tr><td>数据可靠性</td><td>Kafka使用异步刷盘方式，异步Replication</td><td>RocketMQ支持异步实时刷盘，同步刷盘，同步Replication，异步Replication</td><td>1.RocketMQ的同步刷盘在单机可靠性上比Kafka更高，不会因为操作系统Crash，导致数据丢失。在强可靠性要求场景可用 2.另外Kafka的Replication以topic为单位，支持主机宕机，备机自动切换，但是这里有个问题，由于是异步Replication，那么切换后会有数据丢失，且会有消息乱序的风险。</td></tr><tr><td>消费失败重试</td><td>Kafka消费失败不支持自动重试</td><td>RocketMQ消费失败支持定时重试，每次重试间隔时间顺延</td><td>1. kafka如果需要实现消息重试，需要自己实现取出消息重新发送一遍。</td></tr><tr><td>消息顺序</td><td>Kafka支持消息顺序，但是一台Broker宕机后，就会产生消息乱序</td><td>RocketMQ支持严格的消息顺序，在顺序消息场景下，一台Broker宕机后，发送消息会失败，但是不会乱序</td><td>当broker的leader挂掉瞬间，旧的leader对client可见，所以可能存在多个消费者消费不同的broker情况，造成消息乱序消费。</td></tr><tr><td>定时消息消费</td><td>Kafka不支持定时消息</td><td>RocketMQ支持</td><td>开源版本RocketMQ仅支持定时Level阿里云ONS支持定时Level，以及指定的毫秒级别的延时时间</td></tr><tr><td>事物消息</td><td>不支持</td><td>支持但是没有超时回查机制</td><td>阿里内部版本支持完整实物消息</td></tr><tr><td>消息回溯</td><td>可以按照Offset来回溯消息</td><td>支持按照时间来回溯消息，精度毫秒，例如从一天之前的某时某分某秒开始重新消费消息</td><td>典型业务场景如consumer做订单分析，但是由于程序逻辑或者依赖的系统发生故障等原因，导致今天消费的消息全部无效，需要重新从昨天零点开始消费，那么以时间为起点的消息重放功能对于业务非常有帮助。</td></tr><tr><td>消息消费并行度</td><td>Kafka的消费并行度依赖Topic配置的分区数，如分区数为10，那么最多10台机器来并行消费（每台机器只能开启一个线程），或者一台机器消费（10个线程并行消费）。即消费并行度和分区数一致</td><td>顺序消费方式并行度同Kafka完全一致<br> 乱序方式并行度取决于Consumer的线程数，如Topic配置10个队列，10台机器消费，每台机器100个线程，那么并行度为1000。</td><td>RoketMQ在不要求顺序消费时，并行度可以很高</td></tr><tr><td>开发语言</td><td>Scala</td><td>Java</td><td>分布式系统中，Java的语言生态更好</td></tr><tr><td>消息堆积能力</td><td>非常好，上亿级</td><td>非常好，上亿级</td><td>消息堆积能力都非常好</td></tr><tr><td>商业支持</td><td>LinkIn开源</td><td>Alibaba开源</td><td></td></tr><tr><td>成熟度</td><td>Kafka在日志领域比较成熟</td><td>RocketMQ在阿里集团内部有大量的应用在使用，每天都产生海量的消息，并且顺利支持了多次天猫双十一海量消息考验，是数据削峰填谷的利器。</td><td>商业场景RocketMQ更加适合，并且更符合开发习惯</td></tr></tbody></table><h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><h2 id="为什么使用消息队列-消息队列的作用是什么"><a href="#为什么使用消息队列-消息队列的作用是什么" class="headerlink" title="为什么使用消息队列?消息队列的作用是什么?"></a>为什么使用消息队列?消息队列的作用是什么?</h2><p>异步化、解耦、消除峰值</p><h2 id="Kafka-的-Topic-和分区内部是如何存储的，有什么特点"><a href="#Kafka-的-Topic-和分区内部是如何存储的，有什么特点" class="headerlink" title="Kafka 的 Topic 和分区内部是如何存储的，有什么特点?"></a>Kafka 的 Topic 和分区内部是如何存储的，有什么特点?</h2><p>新建topic时指定分区数量，并为每个分区维护消息数据存储文件，随着topic数量增加，文件数量增加，读写性能下降。</p><h2 id="与传统的消息系统相比，Kafka-的消费模型有什么优点"><a href="#与传统的消息系统相比，Kafka-的消费模型有什么优点" class="headerlink" title="与传统的消息系统相比，Kafka 的消费模型有什么优点?"></a>与传统的消息系统相比，Kafka 的消费模型有什么优点?</h2><ol><li>Kafka是一个分布式系统，易于向外扩展。</li><li>它同时为发布和订阅提供高吞吐量。</li><li>它支持多订阅者，当失败时能自动平衡消费者。</li><li>消息的持久化。</li></ol><h2 id="Kafka-如何实现分布式的数据存储与数据读取"><a href="#Kafka-如何实现分布式的数据存储与数据读取" class="headerlink" title="Kafka 如何实现分布式的数据存储与数据读取?"></a>Kafka 如何实现分布式的数据存储与数据读取?</h2><p>日志形式存储，并生成索引文件，能够通过offset下标快速定位数据行</p><h2 id="Kafka-为什么比-RocketMQ-支持的单机-Partition-要少"><a href="#Kafka-为什么比-RocketMQ-支持的单机-Partition-要少" class="headerlink" title="Kafka 为什么比 RocketMQ 支持的单机 Partition 要少?"></a>Kafka 为什么比 RocketMQ 支持的单机 Partition 要少?</h2><p>数据存储形式决定，kafka为每个分区都生成存储文件，当较多的Parition时，随机写冲突加大，性能下降</p><h2 id="为什么需要分区，也就是说主题只有一个分区，难道不行吗"><a href="#为什么需要分区，也就是说主题只有一个分区，难道不行吗" class="headerlink" title="为什么需要分区，也就是说主题只有一个分区，难道不行吗?"></a>为什么需要分区，也就是说主题只有一个分区，难道不行吗?</h2><p>分区是为了尽可能的减少资源竞争，增加处理并行度</p><h2 id="日志为什么需要分段"><a href="#日志为什么需要分段" class="headerlink" title="日志为什么需要分段?"></a>日志为什么需要分段?</h2><p>方便快速清理无用数据，提高磁盘利用率</p><h2 id="Kafka-是依靠什么机制保持高可靠，高可用"><a href="#Kafka-是依靠什么机制保持高可靠，高可用" class="headerlink" title="Kafka 是依靠什么机制保持高可靠，高可用?"></a>Kafka 是依靠什么机制保持高可靠，高可用?</h2><p>利用zk实现Master/Slave主备切换</p><h2 id="消息队列如何保证消息幂等"><a href="#消息队列如何保证消息幂等" class="headerlink" title="消息队列如何保证消息幂等?"></a>消息队列如何保证消息幂等?</h2><p>利用消息的唯一标识，在业务系统中做好幂等，消息中间件本身无需保证幂等</p><h2 id="让你自己设计个消息队列，你会怎么设计，会考虑哪些方面"><a href="#让你自己设计个消息队列，你会怎么设计，会考虑哪些方面" class="headerlink" title="让你自己设计个消息队列，你会怎么设计，会考虑哪些方面?"></a>让你自己设计个消息队列，你会怎么设计，会考虑哪些方面?</h2><ul><li>消息的持久化</li><li>分布式可靠性</li><li>消息堆积能力</li><li>消息重试</li></ul><blockquote><p>参考文章：<br><a href="https://cloud.tencent.com/developer/news/306092" target="_blank" rel="noopener">分布式消息队列RocketMQ与Kafka架构上的巨大差异</a><br><a href="https://zl378837964.iteye.com/blog/2421888" target="_blank" rel="noopener">RocketMQ与Kafka对比</a><br><a href="https://github.com/javahongxi/whatsmars/wiki/RocketMQ%E5%90%90%E8%A1%80%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">RocketMQ吐血总结</a><br><a href="https://www.cnblogs.com/xiaodf/p/5075167.html" target="_blank" rel="noopener">RocketMQ原理介绍最透彻的文章</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
            <tag> Kafka </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建的介绍</title>
      <link href="/blog-introduce/"/>
      <url>/blog-introduce/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这是我修改自<a href="https://github.com/godweiyang/hexo-matery-modified" target="_blank" rel="noopener">hexo-theme-matery</a>的个性化hexo博客模板，主要修改了一些个性化配置，为了方便大家直接搭建使用。</p><p><img src="../images/blog-introduce/image-20191128160144163.png" alt="image-20191128160144163"></p><h1 id="我的博客演示"><a href="#我的博客演示" class="headerlink" title="我的博客演示"></a>我的博客演示</h1><p><a href="https://okeeper.com">https://okeeper.com</a></p><h1 id="快速方法"><a href="#快速方法" class="headerlink" title="快速方法"></a>快速方法</h1><h2 id="1-下载主题源码"><a href="#1-下载主题源码" class="headerlink" title="1. 下载主题源码"></a>1. 下载主题源码</h2><p>为了减小源码的体积，我将插件目录<code>node_modules</code>进行了压缩，大家下载完后需要解压。另外添加水印需要的字体文件我也删除了，大家可以直接从电脑自带的字体库中拷贝。</p><ul><li>首先运行<code>git clone git@github.com:godweiyang/hexo-matery-modified.git</code>将所有文件下载到本地。</li><li>解压<code>node_modules.zip</code>，然后删除<code>node_modules.zip</code>和<code>.git</code>文件夹。</li><li>还缺一个字体（为图片添加水印需要用到），去<code>C:\Windows\Fonts</code>下找到<code>STSong Regular</code>，复制到<code>hexo-matery-modified</code>文件夹下。</li></ul><h2 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2. 环境准备"></a>2. 环境准备</h2><h3 id="2-1-安装Node-js"><a href="#2-1-安装Node-js" class="headerlink" title="2.1 安装Node.js"></a>2.1 安装Node.js</h3><p>首先下载稳定版Node.js，我这里给的是64位的。<br>安装选项全部默认，一路点击Next。</p><p>最后安装好之后，按Win+R打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p><p>添加国内镜像源<br>如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p><pre><code>npm config set registry https://registry.npm.taobao.org</code></pre><h3 id="2-2-安装hexo"><a href="#2-2-安装hexo" class="headerlink" title="2.2 安装hexo"></a>2.2 安装hexo</h3><pre><code>npm i hexo-cli -ghexo -vhexo init# 安装必要组件npm install# 生成静态文件hexo g#启动服务器hexo s</code></pre><h2 id="3-修改配置-config-yml"><a href="#3-修改配置-config-yml" class="headerlink" title="3. 修改配置_config.yml"></a>3. 修改配置<code>_config.yml</code></h2><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 修改git配置，当执行 `hexo d` 时, 将自动提交到这个git地址</span><span class="token attr-name">deploy</span><span class="token punctuation">:</span><span class="token attr-name">-</span> <span class="token attr-value">type: git</span><span class="token attr-name">  repository</span><span class="token punctuation">:</span> <span class="token attr-value">https://github.com/okeeper/okeeper.github.io.git</span><span class="token attr-name">  branch</span><span class="token punctuation">:</span> <span class="token attr-value">master</span><span class="token comment" spellcheck="true"># 修改标题和关键字</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-在github中添加你的博客项目"><a href="#4-在github中添加你的博客项目" class="headerlink" title="4. 在github中添加你的博客项目"></a>4. 在github中添加你的博客项目</h2><p>一般为 {你的id}.github.io, 这样后续就可以直接通过 {你的id}.github.io访问到你的blog</p><h2 id="5-编译-amp-发布"><a href="#5-编译-amp-发布" class="headerlink" title="5. 编译&amp;发布"></a>5. 编译&amp;发布</h2><pre><code># 编译source目录下的文章生成public静态文件hexo g# 提交到你的blog仓库hexo d</code></pre><h1 id="个性化"><a href="#个性化" class="headerlink" title="个性化"></a>个性化</h1><h3 id="1-添加水印"><a href="#1-添加水印" class="headerlink" title="1. 添加水印"></a>1. 添加水印</h3><p>为了防止别人抄袭你文章，可以把所有的图片都加上水印，方法很简单。<br>首先在博客根目录下新建一个watermark.py，代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token keyword">import</span> sys<span class="token keyword">import</span> glob<span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">from</span> PIL <span class="token keyword">import</span> ImageDraw<span class="token keyword">from</span> PIL <span class="token keyword">import</span> ImageFont<span class="token keyword">def</span> <span class="token function">watermark</span><span class="token punctuation">(</span>post_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> post_name <span class="token operator">==</span> <span class="token string">'all'</span><span class="token punctuation">:</span>        post_name <span class="token operator">=</span> <span class="token string">'*'</span>    dir_name <span class="token operator">=</span> <span class="token string">'source/_posts/'</span> <span class="token operator">+</span> post_name <span class="token operator">+</span> <span class="token string">'/*'</span>    <span class="token keyword">for</span> files <span class="token keyword">in</span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span>dir_name<span class="token punctuation">)</span><span class="token punctuation">:</span>        im <span class="token operator">=</span> Image<span class="token punctuation">.</span>open<span class="token punctuation">(</span>files<span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>im<span class="token punctuation">.</span>getbands<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">:</span>            im <span class="token operator">=</span> im<span class="token punctuation">.</span>convert<span class="token punctuation">(</span><span class="token string">'RGB'</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span>        font <span class="token operator">=</span> ImageFont<span class="token punctuation">.</span>truetype<span class="token punctuation">(</span><span class="token string">'STSONG.TTF'</span><span class="token punctuation">,</span> max<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>im<span class="token punctuation">.</span>size<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        draw <span class="token operator">=</span> ImageDraw<span class="token punctuation">.</span>Draw<span class="token punctuation">(</span>im<span class="token punctuation">)</span>        draw<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">(</span>im<span class="token punctuation">.</span>size<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> im<span class="token punctuation">.</span>size<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                  u<span class="token string">'@godweiyang'</span><span class="token punctuation">,</span> fill<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> font<span class="token operator">=</span>font<span class="token punctuation">)</span>        im<span class="token punctuation">.</span>save<span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>        watermark<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[usage] &lt;input>'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字体也放根目录下，自己找字体。然后每次写完一篇文章可以运行python3 watermark.py postname添加水印，如果第一次运行要给所有文章添加水印，可以运行python3 watermark.py all</p><h3 id="2-添加快速评论"><a href="#2-添加快速评论" class="headerlink" title="2. 添加快速评论"></a>2. 添加快速评论</h3><p>注册：<a href="https://leancloud.cn/" target="_blank" rel="noopener">https://leancloud.cn/</a></p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey.</span><span class="token key atrule">valine</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">appId</span><span class="token punctuation">:</span> ***修改成你自己的appId  <span class="token key atrule">appKey</span><span class="token punctuation">:</span> ***修改成你自己的appKey  <span class="token key atrule">notify</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">verify</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">visitor</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">avatar</span><span class="token punctuation">:</span> <span class="token string">'wavatar'</span> <span class="token comment" spellcheck="true"># Gravatar style : mm/identicon/monsterid/wavatar/retro/hide</span>  <span class="token key atrule">pageSize</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token key atrule">placeholder</span><span class="token punctuation">:</span> <span class="token string">'来都来了，不留点啥啊！'</span> <span class="token comment" spellcheck="true"># Comment Box placeholder</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-给文章添加背景音乐"><a href="#3-给文章添加背景音乐" class="headerlink" title="3. 给文章添加背景音乐"></a>3. 给文章添加背景音乐</h3><p>在.md的markdown文件的开头添加这段代码</p><pre><code>&lt;div align=&quot;middle&quot;&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=407679465&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;</code></pre><h3 id="4-Front-matter-选项详解"><a href="#4-Front-matter-选项详解" class="headerlink" title="4. Front-matter 选项详解"></a>4. Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="搭建教程请参考"><a href="#搭建教程请参考" class="headerlink" title="搭建教程请参考"></a>搭建教程请参考</h1><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">https://godweiyang.com/2018/04/13/hexo-blog/</a></p><h1 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h1><p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p><p>然后打开<code>source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p><h1 id="结合Typora的markdown编辑器"><a href="#结合Typora的markdown编辑器" class="headerlink" title="结合Typora的markdown编辑器"></a>结合Typora的markdown编辑器</h1><p>有强迫症的人适合当程序员，应为容不得半点不舒服</p><p>对比了市面上的主流markdown编辑器，兼顾以下几个点的，好像只有Typora了</p><ul><li>即时预览，当你输入markdown关键字时自动变换预览格式</li><li>截图直接粘贴生成图片存入指定目录，设置见文件-&gt;偏好设置&gt;图像&gt;路径配置</li><li>简洁并支持主题自定义</li><li>开源免费</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> typora-vue-theme </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
